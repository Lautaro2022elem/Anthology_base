-- Cleanup and reformat
-- MCM integration
-- Slight optimizations
-- You are free to modify this mess of a code


-- =============================================================
--
-- "Dynamic Mutants" - script
--
-- for Anomaly 1.5 24/1/2021
--
-- created by bmblbx176 (Leviathan)
--
-- =============================================================
---[[
local enable_dbg = false

local monster_names = { --Just copy pasta of sections from DLTXed dyn.mutants
    ["dog_shepherd"] = true,
    ["dog_shepherd_small"] = true,
    ["dog_shepherd_big"] = true,
    ["dog_shepherd_bigger"] = true,
    ["dog_shepherd_largest"] = true,
    ["dog_shepherd_80"] = true,
    ["dog_shepherd_90"] = true,
    ["dog_shepherd_100_alt"] = true,
    ["dog_shepherd_110"] = true,
    ["fox_red"] = true,
    ["m_boar_big_monster"] = true,
    ["boar_vision_free1"] = true,
    ["boar_vision_danger1"] = true,
    ["m_boar_attack_params1"] = true,
    ["m_boar_attack_effector1"] = true,
    ["m_Boar_damage1"] = true,
    ["boar_critical_wound_bones_head1"] = true,
    ["boar_critical_wound_bones_torso1"] = true,
    ["boar_critical_wound_bones_legs1"] = true,
    ["boar_terrain1"] = true,
    ["m_boar_step_params1"] = true,
    ["boar_immunities1"] = true,
    ["boar_protections1"] = true,
    ["boar_big_monster"] = true,
    ["boar_protections_big_monster"] = true,
    ["boar_immunities_big_monster"] = true,
    ["boar_attack_params_big_monster"] = true,
    ["boar_big_monster_v2"] = true,
    ["mwolf"] = true,
    ["mwolf_immunities_strong"] = true,
    ["mwolf_attack_params_strong"] = true,
    ["mwolf_leader"] = true,
    ["mwolf_immunities_leader"] = true,
    ["mwolf_attack_params_leader"] = true,
    ["mwolf_damage"] = true,
    ["mwolf_maverick"] = true,
    ["mwolf_immunities_maverick"] = true,
    ["mwolf_attack_params_maverick"] = true,
    ["mwolf_top_dog"] = true,
    ["mwolf_immunities_top_dog"] = true,
    ["mwolf_attack_params_top_dog"] = true,
    ["m_crow_default"] = true,
    ["m_crow_bigger"] = true,
    ["m_crow_big"] = true,
    ["m_crow_largest"] = true,
    ["chicken_default"] = true,
    ["chicken_immunities"] = true,
    ["chicken_attack_params"] = true,
    ["vendigo"] = true,
    ["vendigo_step_params"] = true,
    ["vendigo__attack_params"] = true,
    ["vendigo_immunities"] = true,
    ["tark"] = true,
    ["tark_default"] = true,
    ["tark_immunities_default"] = true,
    ["tark_attack_params_default"] = true,
    ["tark_damage"] = true,
    ["tark_smaller"] = true,
    ["tark_immunities_smaller"] = true,
    ["tark_attack_params_smaller"] = true,
    ["poltergeist_build_attack_params"] = true,
    ["poltergeist_build_step_params"] = true,
    ["poltergeist_build_immunities"] = true,
    ["poltergeist_build_vision_free"] = true,
    ["poltergeist_build_vision_danger"] = true,
    ["poltergeist_build"] = true,
    ["m_poltergeist_build_damage"] = true,
    ["m_medved_e"] = true,
    ["medwed_attack_params"] = true,
    ["medwed_attack_effector"] = true,
    ["medwed_damage"] = true,
    ["medwed_critical_wound_bones_head"] = true,
    ["medwed_critical_wound_bones_torso"] = true,
    ["medwed_critical_wound_bones_legs"] = true,
    ["medwed_vision_free"] = true,
    ["medwed_vision_danger"] = true,
    ["medwed_terrain"] = true,
    ["medwed_step_params"] = true,
    ["medwed_immunities"] = true,
    ["medved"] = true,
    ["medved_immunities_default"] = true,
    ["medved_attack_params_default"] = true,
    ["medved_smaller"] = true,
    ["medved_immunities_smaller"] = true,
    ["medved_attack_params_smaller"] = true,
    ["medved_dark"] = true,
    ["medved_immunities_dark"] = true,
    ["medved_attack_params_dark"] = true,
    ["rotan"] = true,
    ["rotan_vision_free"] = true,
    ["rotan_vision_danger"] = true,
    ["rotan_terrain"] = true,
    ["rotan_protections"] = true,
    ["m_rotan_damage"] = true,
    ["rotan_immunities"] = true,
    ["m_rotan_attack_params"] = true,
    ["m_rotan_step_params"] = true,
    ["rotan_normal"] = true,
    ["piranha_default"] = true,
    ["piranha_immunities_default"] = true,
    ["piranha_attack_params_default"] = true,
    ["piranha_smaller"] = true,
    ["piranha_immunities_smaller"] = true,
    ["piranha_attack_params_smaller"] = true,
    ["piranha_bigger"] = true,
    ["piranha_immunities_bigger"] = true,
    ["piranha_attack_params_bigger"] = true,
}

local item_table = (function()
    local t = {}
    for typ, v in pairs(_ITM) do
        for sec, _ in pairs(v) do
            t[sec] = true
        end
    end
    return t
end)()

local math_random = math.random
local math_floor = math.floor
local math_sqrt = math.sqrt
local math_abs = math.abs
local string_match = string.match
local string_find = string.find
local string_sub = string.sub
local string_gsub = string.gsub
local str_explode = str_explode
local time_global = time_global
local tostring = tostring
local tonumber = tonumber

function msg(txt)
    -- news_manager.send_tip (db.actor, txt, nil, nil, 10000 )
end
--]]
-- NOTE: Snorks, Geists, Karlik, dogs, cats - are excluded from this addon.
-- They are numerous and annoying enough, AND also not 'suitable' for the purposes of this addon.
-- NOTE2: the mutants are added in 'waves': at start, then each consecutive day, (if conditions, probabilites are met), up until it reaches the limit, then, it waits for sufficient number of mutants to be culled, before it adds new ones
-- NOTE3: in all maps, except CNPP_Underground, (no conditions suitable there; at most, a few rodents in the Wishgranter 'room', and even that is a bit of a 'stretch')
-- NOTE4: if 'addit._mutants' setting is kept 'disabled' in settings, during all savings of a savegame,
-- that savegame (will contain only Anomaly mutants) and will run fine even if the whole 'GAMEDATA' folder is removed
local TIME_INTERVAL_BETWEEN_CONSECUTIVE_SPAWNS = 1 -- in days; 'default' is every 3-5 days (4-1, 4+1)
local DAYS_THRESHOLD = 0 -- 1 -- i.e. +- 1 days from the above value, example: every 3-5 days; (if set to 0, only the above value gets used)
local ADD_STALKERS = true -- set this to 'false', to disable the addition of a few stalkers in UG maps and in some other, specific locations (*WiP)
-- in short, this enables/disables the addition of any stalkers by this addon
local STALKERS_PERC_VARIETY_MIN = -15 -- these add variety/unpredictability to the particular probability that a stalker will appear at its designated position
-- example: typical probability is around 40%, (30-60)
local STALKERS_PERC_VARIETY_MAX = 10 --- this will result in the probability ranging from 40 -30, 40 +10, i.e. 10 - 50 %
--- meaning, some times there will be very few stalkers, other times, a group of them
local ENABLE_MISC_ALIFE = true -- enable/disable the inclusion of the occasional Controller, Burer... in the UG maps and some of the SPECIFIC_LOCATIONS
--- if needed, setting these two factors to 0, will effectively disable them
local PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS_factor = 0.057 -- decrease this coeff, for less alife at specific_locations, (Zaton,iron forest, Meadows,building/factory, etc...)
local PERCENTAGE_TO_SPAWN_UG_MUTANTS_factor = 0.078 -- the coefficient that determines the PERCENTAGE of populating the UnderGround maps
-- this is multiplied by the 'SLIDER setting' for the DynMutants
--- example: if set at 1000, percentage for UG maps will be 1000*0.08 = 80%
--------- this provides very close to the intended numbers/experience in the UG maps
---------- carefully fine-tuned through many thorough visits of the UG maps
-- Point of reference: the 'global' percentage for almost all other maps is, currently, at 13% (~1/6th)
local UG_maps_are_populated = false -- a 'flag', to keep track of the status
local UG_maps_got_populated_at_day = -30 --
local depopulate_UG_maps_after_N_days_of_no_visit = 2 -- UG maps will get depopulated after this period AND when Player is in a no_UG map
--- NOTE: all 7 UG maps get populated on the first visit to any of them
local SPEC_LOC_got_populated_at_day = -30 --
local depopulate_SPEC_LOC_after_N_days_of_no_visit = 2 -- SPECIFIC_LOCATIONS will get depopulated after this period AND when Player is in another map
--- NOTE: any single one of the SPEC_LOCATIONS gets populated when Player gets near
--  with this at 80+, it results in a similar prob to encounter the addit.mutants as is to encounter a chimera.
-- NOTE: if all addit.mutants are not enabled, it can still add a (vanilla) Giant intead of a Chimera
-- UNLESS the main checkbox is also not enabled
local addit_mutants_at_SPEC_LOC_instead_of_a_chosen_chimera_prob = 70
-- this enables for a probability (in %) that, when a CHIMERA is selected for addition in a SPECIFIC_LOCATIONS,
-- with this probability, it may be 'switched' to one of the additional mutants, if they are enabled/selected
-- the bigger ones can go only in the larger/wider SPEC_LOC, selectively
-- among other, the Controller's cave in Zaton can also be occupied (temporarily) by a:
-- medved, monster boar, vendigo, giant, tark, volk
local radius_to_SPEC_LOC = 42 -- distance from the 'trigger' coord, within which it will populate that specific_location
-- NOTE: for some of the spec_loc, only one 'trigger_coord' is set (in the ~center), with "*2" extended range, (instad of several with default range)
-- ex: Jupiter Volkhov Complex,
-- initialize the SPEC_LOCATIONS "populated" 'flags'
local SPECIFIC_LOCATIONS_populated = {
    zaton_iron_forest = "",
    zaton_bs_lair = "",
    zaton_controller_cave = "",
    jupiter_volkhov_complex = "",
    jupiter_abandoned_factory = "",
    dead_city_abandoned_school = "",
    army_warehouses_bs_village = "",
    truck_cemetery_forest = "",
    meadows_building_factory = "",
    radar_ne_base = ""
}
local timestamp_when_playthrough_started_in_days = 0 -- to get TIME (days) from start; global, and save it in the savegame
-- (i.e. RegisterScriptCallback("actor_on_first_update",get_timestamp_when_playthrough_started)
-- timestamp_when_playthrough_started = utils_data.CTimeToSec(game.get_game_time()) / 3600)
-- UPDATE: set all aboveground maps get new mutants together, so, '= 1' past v1.35 DynMut
local POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED = 1 -- 3 -- -- example: when to populate the less_freq_visited maps: at start, then after 1*3*4th day, then after 2*3*4th day, then after 3*3*4th day...
-- less_freq_visited maps: CNPP N/S, Limansk, Hospital, Meadows, Yantar, Generators
local TIMES_SPAWNED = 0 -- important for the above one
local SAFE_DISTANCE_AROUND_PLAYER = 35 -- 1 -- 55 --  -- (i.e. 'Exclusion Radius'), in meters, 'safe area' around the Player that DYNAMIC_MUTANTS won't spawn in; NOTE: they CAN spawn if position is > 2m above the Player's position, (ex: Player is in UG shelter, mutant is above ground, rodents in House atics, etc )
local TOTAL_NUMBER_OF_MUTANTS_ADDED = 0 -- to count them, and potentially 'manage' the numbers
local NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = 0 --
local ADDON_DISABLED_0_VALUE = false -- it will be true if the slider is set at 0, effectively disabling the addition of new mutants
local LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON_DEFAULT = 1000 -- max number of mutants it will add before it starts to wait for their numbers to be decreased before adding more
local LIMIT_COEFFICIENT = 0.85 -- example: 1000 * 0.85 == 850 <-- the number above at which it won't add another wave of mutants
-- ... and will wait for mutant_numbers to go down
-- that 'wave' (at ~800-840) will probably make the mutant_numbers reach the limit of 1000
-- after which, it will wait for their numbers to get below 850 to add new ones.
-- in short, the mutant_numbers will 'hover' between approx. 850 - 1000
local MESSAGE_DURATION = 17 -- time duration, (in seconds), to show the NUMPAD_MULTIPLY infos
local WAIT_FOR_MUTANTS_TO_BE_CULLED = 0 --- in the above case, the number of mutants that need to be decreased, (waiting), for this addon to add another 'wave' of mutants
-- NOTE: if set to '0', it will automatically select the number equal to the last 'wave' added by this addon
local MUTANTS_DEAD_COUNT = 0 -- to count the culled mutants
local ENOUGH_MUTANTS_CULLED = true -- a 'flag', on whether enough mutants are culled, meaning, 'ready' for another 'wave' of mew mutants
-- it remains 'true', iuntil it reaches the limit (5000, etc) - 'LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON'
local WAIT_FOR_MUTANTS_TO_BE_CULLED_N = 1000 -- after that, it becomes 'true' only when 'WAIT_FOR_MUTANTS_TO_BE_CULLED' mutants are culled
-- UPDATE: increased from the 13%, (in v1.35), to 'compensate' for decreasing the coeff in CNPP N/S maps, (due to performance reasons in those two largest maps)
-- UPDATE2: decrease the percentage for GERMAN_SHEPHERD, FOX, BIRDS, CHICKEN in these 7 maps also, (otherwise, it will have much migher numbers of thes by the 20th day and 1500 mutant_numbers)
local PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT = 15 -- 100 -- -- set the percentage of the number of MUTANTS from the MAX; 30, 60, 100...
local PERCENTAGE_STEP_DECREASE = 1 -- 10 -- decrease of the PERCENTAGE for the next 'wave'
local LOWEST_PERCENTAGE_TO_SPAWN_MUTANTS = 20 -- 100 -- -- lowest percentage, achieved eventually; after that, it will continue with this indefinitely, ( extreme case limit: IDs_utilized < 55.000 )
local PERCENTAGE_TO_SPAWN_GERMAN_SHEPHERD = 65 --30 -- 100 -- tame dog, neutral to/from everything, will stay close to human settlements
local PERCENTAGE_TO_SPAWN_RED_FOX = 35 --55 -- 40  -- 100 -- 30 -- "ambiental fauna" fox, hostile only to/from tushkanos/rats
local PERCENTAGE_TO_SPAWN_CHICKEN = 85 --75 -- 100 -- flightless bird, neutral to/from everything, will stay close to "rural" human settlements, (utilizes German_Shepherd's recorded positions)
local MAX_NUMBER_OF_GERMAN_SHEPHERDS_IN_THE_ZONE = 75 -- will check the Cermnan Shepherd numbers before adding more, won't add if that number is more than this
-- NOTE: up to 3-4 of them in one aboveground map (1-2 per base/settlement), 24 maps
local MAX_NUMBER_OF_RED_FOXES_IN_THE_ZONE = 80 -- 3-6 per map 80 + a 'wave' of them --> max ~100-110
-- NOTE: up to 30-40 can be added in a 'wave'
local MAX_NUMBER_OF_CHICKENS_IN_THE_ZONE = 85 -- 3-6 per settlement, on 8 maps 10 *8 80 -- > 70 + a 'wave' of them --> max ~150
-- UPDATE: with these MAX_NUMBERS_LIMITS set, the percentages for the SHEPHERD, FOX, CHICKEN are not really important,
-- so, even higher perc are good, will add them faster in the playthrough
-- NOTE: will add more in a 'wave' in that case
local PERCENTAGE_TO_SPAWN_RODENTS = 60 -- 20 --
local PERCENTAGE_TO_SPAWN_BOAR_FLESH = 80 -- 20 --
local PERCENTAGE_TO_SPAWN_ZOMBIES_FRACTURE = 70 -- 20 --
local PERCENTAGE_TO_SPAWN_BLOODSUCKER = 42 -- 20 --
local RNG_percentage = 2 -- for 'PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT = 13- -- was 5, appropriate for 30+ %
local DELAY_SPAWN_OF_BLOODSUCKER_FOR_THE_FIRST_N_DAYS = 3 -- 5 -- after this, it will get the value above
-- CAUTION with this, you want BS in the UG labs (ex: AAgroprom UG), from the start
-- UPDATE: there is now a separate spawn_function that 'populates' UG maps when visited,
-- And with nigher percentage than the 'global' one at 13#
local PERCENTAGE_TO_SPAWN_CHIMERA_GIANT = 95 -- 70 -- 30 -- -- set the additional, separate probability to spawn a Chimera/Giant;
-- with 80(%), mostly 1-5, (out od hundreds of other mutants)
-- NOTE: the higher-tier medved/volk will show up also, after the initial 10 days period
local DELAY_SPAWN_OF_CHIMERA_GIANT_FOR_THE_FIRST_N_DAYS = 10 -- after this, it will get the value above /2 (example: 35%)
-- after this *1.5, it will get the value above
-- IMPORTANT: the BIRDS/PIRANHAS 'ignore' the 15%_percentage_limit and the performance_coeff
-- so, set their (~absolute) percentage here
-- NOTE: setting this at 100, will make them show up at all recorded positions dedicated for them
-- reference point: 15; 30 will 'double' their resultant numbers, compared to 'usual' wave
-- PIRANHAS have 343 recorded_positions thr. the world
-- BIRDS have 1909 (Boar/Flesh's)
-- 15-25 piranhas are needed in a level, to get noticed --> ~100-150 are needed thr. the world (11 suitable maps)
--> 40-45
-- 5-10 birds are needed in a level, to get noticed --> ~150-250 are needed thr. the world (24 aboveground maps)
--> 10-15
local PERCENTAGE_TO_SPAWN_PIRANHAS = 7 -- 55 -- the 'ported' "Catfish", placed in the Komar, and their own recorded positions
-- UPDATE: this percentage for the Piranhas is 'absolute', 35% in v1.35, 35% of that for next version --> 12
--> ex: Swamps, 133 recorded_pos: 0.12 *133 =16 (per 'wave')
--> ex: Zaton, 87 recorded_pos: 0.12 *87 =10 (per 'wave')
-- UPDATE: as of v1.4, the BIRDS are removed and re-added at every 'spawn_wave',
-- this will keep their numbers more consistent
-- so, an increase to 100, (from 75, in v1.35), is warranted
local PERCENTAGE_TO_SPAWN_BIRDS = 45 -- 75 -- 55 -- -- for the BIRDS, at 100, will have one per each Boar/Flesh recorded_pos
-- with the coeff (for performance) factored in
--- they will get shot by the Player, or by an emission/psistorm
local MAX_NUMBER_OF_ADDIT_BIRDS_IN_THE_ZONE = 95 -- will check the Birds numbers before adding more, won't add if that number is more than this
-- NOTE: approx. 10-25 birds are added per 'wave', on average
-- UPDATE: birds are now set to use the optimization_coeff, (piranhas have their own recorded_pos and their percentage here is 'absolute')
-- 5-10 birds are needed in a level, to get noticed --> ~150-250 are needed thr. the world (24 aboveground maps)
-- 1900 *0.13 *0.8 = 198 birds possible in a 'wave' * 0.12 for Zaton/Jupiter ('perf_optimized'), etc...
-- example: Zaton, 211 (pos) *0.13 *0.8 *0.12 == 2.6 (~3 birds per wave)
--> set it at 100
-- NOTE: there are 120 recorded positions for Chimera/Giant all thr. the Zone
-- PERCENTAGE_TO_SPAWN_MWOLF * (performance_) coeff
--> ona loose average, 120 *0.5 *0.4 = 25-30 'tough' addit. mutants predators per 'wave'
---> set the percentage at 27%
local PERCENTAGE_TO_SPAWN_MWOLF = 42 -- 35 -- 50 -- the 'ported' "mwolf", placed in the Chimera/Giant group, and their positions
local ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS_DEFAULT = true -- to further read the CHECK selection in the in-game settings
-- this check 'expands' on the VOLK, MEDVED, TARK, PIRANHA, BIRDS, GERMAN SHEPHERD
-- if ENABLED, it will spawn VOLK,MEDVED,TARK on chimera/giant positions, PIRANHA on its own recorded_positions
-- includes the German Shepherd
--- IF THIS IS 'false', THIS ADDON IT WILL ONLY ADD VANILLA MUTANTS
-- IMPORTANT: this setting is to offer DYNAMIC_MUTANTS numbers BEYOND the intended 100% of this addon
-- in short, it spawns N 'waves' of mutants at once, (instead of only one per 4-6 days)
-- CAUTION: change with care; in any case, a value of 2 would be 'max' that is advisable, (beyond that, immersion suffers, and potentially performance issues arise)
--- there is implemented a 'just-in-case' check/limit at 55.000 IDs utilized (max limit: 65534 IDs)
INCREASED_SPAWN_MUTANTS_FACTOR = 1 -- 2 --
-- whenever Anomaly's engine becomes multi-threaded, and the ID limit is greatly increased,
-- this addon can offer/supply tens of thousands of mutants all thr. the Zone, at ~6000 carefully selected positions
local last_time_to_spawn_dynamic_mutants = 0
local next_time_to_spawn_dynamic_mutants = 0 -- 0, for the very first spawn; time interval for next spawn, (in seconds), from last_time_to_spawn
local IDs_utilized_current_number = 0 -- to initialize it, for the ID counter
local MUTANT_IDS_IN_A_TABLE = {} -- to store the created mutant IDs, and count, manage them, etc. may even decrease their heatlh to 0.2
local MUTANT_IDS_IN_A_TABLE_UG = {}
local MUTANT_IDS_IN_A_TABLE_SPEC_LOC = {}
-- to 'modularly' remove any of the addit. mutant that has been spawned, but not selected in SETTINGS
local ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS = true
local ENABLE_THE_INCLUSION_OF_VOLK_DEFAULT = true
local ENABLE_THE_INCLUSION_OF_MEDVED_DEFAULT = true
local ENABLE_THE_INCLUSION_OF_TARK_DEFAULT = true
local ENABLE_THE_INCLUSION_OF_PIRANHA_DEFAULT = true
local ENABLE_THE_INCLUSION_OF_SHEPHERD_FOX_BIRDS_DEFAULT = true
local ENABLE_THE_INCLUSION_OF_MONSTER_BOAR_DEFAULT = true
local ENABLE_THE_INCLUSION_OF_VENDIGO_DEFAULT = true

local actor_on_update_time = 0
local actor_on_update_timer = 7000

local dyn_mutants_enable_volk = true
local dyn_mutants_enable_tark = true
local dyn_mutants_enable_medved = true
local dyn_mutants_enable_monster_boar = true
local dyn_mutants_enable_vendigo = true
local dyn_mutants_enable_piranha = true
local dyn_mutants_enable_shepherd_fox_birds = true
local dyn_mutants_enable_all_additional_mutants = true
local dyn_mutants_target_numbers = 200
local LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON = dyn_mutants_target_numbers

-- initialize the various dynamic_mutants tables
-- default/original model -- 120% size
local ___Dynamic_Mutants_GERMAN_SHEPHERD___ = {
    "dog_shepherd",
    "dog_shepherd_80",
    "dog_shepherd_90",
    "dog_shepherd_100_alt",
    "dog_shepherd_110",
    "dog_shepherd_big"
}
local Dynamic_Mutants_GERMAN_SHEPHERD___NUMBER_of_ENTRIES = 5 -- 1 --
local ___Dynamic_Mutants_FOX_RED___ = {"fox_red"}
local Dynamic_Mutants_FOX_RED___NUMBER_of_ENTRIES = 1 -- 1 --
local ___Dynamic_Mutants_CHICKEN___ = {"chicken_default"}
local Dynamic_Mutants_CHICKEN___NUMBER_of_ENTRIES = 1 -- 1 --
local ambiental_fauna_names = {"dog_shepherd", "chicken_default", "fox_red"}
local ___Dynamic_Mutants_RODENTS___ = {
    "rat_normal",
    "rat_strong",
    "rat_weak",
    "rat_strong",
    "rat_strong",
    "tushkano_normal",
    "tushkano_weak",
    "tushkano_strong_b",
    "tushkano_normal_c",
    "simulation_rodents",
    "simulation_rodents"
}
local Dynamic_Mutants_RODENTS___NUMBER_of_ENTRIES = 11 -- 1 --
local ___Dynamic_Mutants_BOAR_FLESH___ = {
    "boar_normal",
    "flesh_01a_normal",
    "flesh_02a_strong",
    "flesh_03a_normal",
    "flesh_normal",
    "flesh_strong",
    "flesh_weak",
    "simulation_boar_flesh",
    "simulation_boar_flesh"
}
local Dynamic_Mutants_BOAR_FLESH___NUMBER_of_ENTRIES = 9 -- 1 --
-- removed the (transparent) "zombie_ghost"; it is better suited for appearing at nights, (example: in the 'Dynamic NOCTURNAL Mutants' addon)
local ___Dynamic_Mutants_ZOMBIES_FRACTURE___ = {
    "poltergeist_build",
    "poltergeist_build",
    "zombie_normal",
    "zombie_strong",
    "zombie_weak",
    "zombie_ghol",
    "zombie_teta",
    "zombi_x3",
    "zombi_x4",
    "zombi_9",
    "zombie_blind",
    "zombie_fake",
    "zombie_teta",
    "zombie_wich",
    "zombi_babka_1",
    "zombi_babka_2",
    "zombi_babka_3",
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "fracture_weak",
    "simulation_zombies_fracture",
    "simulation_zombies_fracture"
}
local Dynamic_Mutants_ZOMBIES_FRACTURE___NUMBER_of_ENTRIES = 23 -- 1 --
local ___Dynamic_Mutants_BLOODSUCKER___ = {
    "bloodsucker_normal",
    "bloodsucker_strong",
    "bloodsucker_weak",
    "bloodsucker_black_strong",
    "bloodsucker_green_normal",
    "bloodsucker_red_weak",
    "lurker_1_strong",
    "lurker_2_strong",
    "lurker_3_strong",
    "simulation_bloodsucker",
    "simulation_bloodsucker"
}
local Dynamic_Mutants_BLOODSUCKER___NUMBER_of_ENTRIES = 11 -- 1 --
local ___Dynamic_Mutants_CHIMERA_GIANT___ = {
    "chimera_normal",
    "chimera_strong",
    "chimera_weak",
    "chimera_normal",
    "chimera_strong4",
    "chimera_weak",
    "gigant_normal",
    "gigant_strong",
    "gigant_weak",
    "gigant_jumper",
    "gigant_jumper",
    "gigant_jumper",
    "mwolf_maverick",
    "mwolf_top_dog",
    "mwolf_maverick",
    "mwolf_top_dog",
    "medved_dark",
    "medved_dark",
    "medved_dark",
    "medved_dark",
    "boar_big_monster",
    "boar_big_monster",
    "boar_big_monster_v2",
    "boar_big_monster_v2",
    "vendigo",
    "vendigo",
    "vendigo"
} -- "simulation_mwolf_pack", mwolf will show up regardless of any Chimera/Giant settings
local Dynamic_Mutants_CHIMERA_GIANT___NUMBER_of_ENTRIES = 27 -- 1 --
local Dynamic_Mutants_CHIMERA_GIANT___CHIMERA_NUMBER_of_ENTRIES = 6
-- NOTE: I added the two biggest VOLKS here, to show up only after 10 days.
-- they are dangerous, on par with the chimera
--- the two smaller ones will show up from the start, ( code is at line ~ 3000 )
-- NOTE2: I added the biggest BEAR here, to show up only after 10 days.
-- it is are dangerous, on par with the chimera
--- the two smaller ones will show up from the start, ( code is at line ~ 3000 )
local ___Dynamic_Mutants_PIRANHA___ = {"piranha_default", "piranha_default", "piranha_smaller", "piranha_bigger"}
local Dynamic_Mutants_PIRANHA___NUMBER_of_ENTRIES = 4 -- 1 --
local ___Dynamic_Mutants_CROWS___ = {
    "m_crow_default",
    "m_crow_default",
    "m_crow_bigger",
    "m_crow_big",
    "m_crow_largest",
    "m_crow_largest"
}
local Dynamic_Mutants_CROWS___NUMBER_of_ENTRIES = 6 -- 1 --
local ___Dynamic_Mutants_FLIES___ = {"fly_default", "fly_smaller"}
local Dynamic_Mutants_FLIES___NUMBER_of_ENTRIES = 2 -- 1 --
----- ================================================================================================================= ------
--- the following tables/function is to 'clear' out any non-included Alife names in tables with kept IDs, (of Alife spawned)
-- i.e. after a mutant/stalker has been created, it can die off, and that same ID be assigned to something else
-- example: spawn and "mwolf", it dies off, that ID number gets assigned to a "boar"/"crow"...
--- these need to be removed, (ex: make 'nil' that table field), so as to keep a more accurate record of spawned Alife, and their numbers
-- NOTE: no need to 'optimize' these tables, (and lose accuracy), the processing is done in less than 0.1 seconds
-- full table of main included mutants (Alife)
local ___MUTANT_IDS_IN_A_TABLE_MAIN__INCLUDED_MUTANT_NAMES___ = {
    "dog_shepherd",
    "fox_red",
    "chicken_",
    "piranha",
    "m_crow_",
    "fly_",
    "rat_normal",
    "rat_strong",
    "rat_weak",
    "tushkano_normal",
    "tushkano_weak",
    "tushkano_strong",
    "boar_normal",
    "flesh_0",
    "flesh_normal",
    "flesh_strong",
    "flesh_weak",
    "zombie_normal",
    "zombie_strong",
    "zombie_weak",
    "zombie_ghol",
    "zombie_ghost",
    "zombie_teta",
    "zombi_x3",
    "zombi_x4",
    "zombie_blind",
    "zombie_fake",
    "zombie_wich",
    "zombi_babka_",
    "zombi_9",
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "bloodsucker_normal",
    "bloodsucker_strong",
    "bloodsucker_weak",
    "bloodsucker_black_",
    "bloodsucker_green_",
    "bloodsucker_red_",
    "lurker_1_",
    "lurker_2_",
    "lurker_3_",
    "chimera_normal",
    "chimera_strong",
    "chimera_weak",
    "gigant_normal",
    "gigant_strong",
    "gigant_weak",
    "mwolf",
    "tark",
    "medved",
    "boar_big_monster",
    "vendigo"
}
-- Alife_names used by the UG spawn function
-- it is slightly different from the 'main spawn' table
-- a lot fdifferent from spec_loc table
-- NOTE: no need to 'optimize' these two tables, the processing is done in less than 0.1 seconds
-- full table of main included mutants (Alife)
local ___MUTANT_IDS_IN_A_TABLE_UG__INCLUDED_MUTANT_NAMES___ = {
    -- in UG maps, on stalkers' rec_pos
    -- MISC_ALIFE, to occasionally spawn in UG maps and SPEC_LOCATIONS
    "sim_",
    "m_controller_normal",
    "m_controller_normal1111",
    "burer_normal",
    "rat_normal",
    "rat_strong",
    "rat_weak",
    "tushkano_normal",
    "tushkano_weak",
    "tushkano_strong",
    "zombie_normal",
    "zombie_strong",
    "zombie_weak",
    "zombie_ghol",
    "zombie_ghost",
    "zombie_teta",
    "zombi_x3",
    "zombi_x4",
    "zombie_blind",
    "zombie_fake",
    "zombie_wich",
    "zombi_babka_",
    "zombi_9",
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "bloodsucker_normal",
    "bloodsucker_strong",
    "bloodsucker_weak",
    "bloodsucker_black_",
    "bloodsucker_green_",
    "bloodsucker_red_",
    "lurker_1_",
    "lurker_2_",
    "lurker_3_",
    "chimera_normal",
    "chimera_strong",
    "chimera_weak",
    "gigant_normal",
    "gigant_strong",
    "gigant_weak"
}
-- all the Alife_names used by the 'append_table' function
-- it is used by the SPEC_LOCATION spawn functions
local ___MUTANT_IDS_IN_A_TABLE_SPEC_LOC__INCLUDED_MUTANT_NAMES___ = {
    "rat_normal",
    "rat_strong",
    "tushkano_normal",
    "tushkano_strong_b",
    "zombie_normal",
    "zombie_strong",
    "zombie_weak",
    "zombi_9",
    "zombi_x3",
    "zombi_x4",
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "fracture_weak",
    "bloodsucker_weak",
    "bloodsucker_normal",
    "bloodsucker_strong",
    "bloodsucker_normal",
    "lurker_1_weak",
    "lurker_2_normal",
    "lurker_3_strong",
    "lurker_2_weak",
    "chimera_strong",
    "chimera_weak",
    "chimera_normal",
    "chimera_strong4",
    "sim_",
    "gigant_normal",
    "gigant_strong",
    "gigant_weak",
    "m_controller_normal",
    "m_controller_normal1111",
    "burer_normal"
}
-- tables with stored spawned mutant/stalker IDs:
-- MUTANT_IDS_IN_A_TABLE
-- MUTANT_IDS_IN_A_TABLE_UG
-- MUTANT_IDS_IN_A_TABLE_SPEC_LOC
-- tables with included mutant_namess:
-- ___MUTANT_IDS_IN_A_TABLE_MAIN__INCLUDED_MUTANT_NAMES___
-- ___MUTANT_IDS_IN_A_TABLE_SPEC_LOC__INCLUDED_MUTANT_NAMES___

local function clean_out_table_from_nonincluded_mutant_names(table_to_clean_out, table_of_mutant_names_to_keep)
    local id_check = 0
    local FOUND_MATCH_IN_TABLE = false
    local ___FILTERED_OBJECTS_MUTANT_NAMES___ = table_of_mutant_names_to_keep
    for iii = 1, #table_to_clean_out do
        id_check = table_to_clean_out[iii]
        if (id_check) and (alife_object(id_check)) then
            -- check whether the name of the current OBJECT has a mutant 'string' in it (example: "rat", "tushkano", etc...)
            FOUND_MATCH_IN_TABLE = false -- start doing a 'match' vs the table_data, when a match is found, 'FOUND_MATCH_IN_TABLE' will be true
            -- iterate all mutant names ( VS the current object_ID_name )
            for n = 1, #___FILTERED_OBJECTS_MUTANT_NAMES___ do
                -- i.e. if didn't had a match yet
                if alife_object(id_check) and (FOUND_MATCH_IN_TABLE == false) then -- some IDs (1-65534) do not contain an object
                    -- if it found a match, i.e. this ID holds an included Alife, then
                    if (string_match(alife_object(id_check):name(), ___FILTERED_OBJECTS_MUTANT_NAMES___[n])) then
                        FOUND_MATCH_IN_TABLE = true -- found a match, exit the current 'for to, table' cycle
                    end
                end
            end
            -- at this point, it has went through the 'filtered table' for that particular ID
            -- IF it has found a match, 'FOUND_MATCH_IN_TABLE' will be 'true'
            -- if it DID NOT found a match, i.e. this ID holds a NON-included Alife, (after going thsough the 'filtered_table' for this ID)
            if (FOUND_MATCH_IN_TABLE == false) then
                -- news_manager.send_tip(db.actor, " ---- Removed IDs for: " .. alife_object(id_check):name() , nil, nil, 10000 )
                table_to_clean_out[iii] = nil -- 'empty' the field, i.e. remove that ID from the table, it doesn't belong here
            end
        end
    end
    return table_to_clean_out -- this table is a 're-vised' version of the starting one,
    -- containing only mutant_names that are allowed, (AND some empty fields, interspersed)
end
----- ================================================================================================================= ------
 ----------------------------------------------------
--  axr_keybind.bind("DIK_NUMPAD9",function(p)
--     if p == 1 then
--         if enable_dbg then spawn_dynamic_mutants() end
--     end
-- end)
--  axr_keybind.bind("DIK_NUMPAD6",function(p)
--     if p == 1 then
--         if enable_dbg then
--             local birds_numbers = count_additional_birds()
--             local table_numbers = count_currently_existing_german_shepherds_foxes_chickens ()
--             msg(" ------------- BIRDS NUMBERS: " .. birds_numbers )
--             msg(" --- GERMAN SHEPHERD NUMBERS: " .. table_numbers[1] )
--             msg(" ------------- FOXES NUMBERS: " .. table_numbers[2] )
--             msg(" ---------- CHICKENS NUMBERS: " .. table_numbers[3] )
--         end
--     end
-- end)
--  axr_keybind.bind("DIK_MULTIPLY",function(p)
--     if p == 1 then
--         if enable_dbg then count_mutant_ids_in_table() end
--     end
-- end)
--  axr_keybind.bind("DIK_SUBTRACT",function(p)
--     if p == 1 then
--         if enable_dbg then despawn_existing_mutants_in_table() end
--     end
-- end)
--  axr_keybind.bind("DIK_NUMPAD1",function(p)
--     if p == 1 then
--         if enable_dbg then spawn_dynamic_mutants_in_UG_maps() end
--     end
-- end)
--  axr_keybind.bind("DIK_NUMPAD4",function(p)
--     if p == 1 then
--         if enable_dbg then count_mutant_ids_in_table() end
--     end
-- end)
--  axr_keybind.bind("DIK_NUMPAD3",function(p)
--     if p == 1 then
--         if enable_dbg then check_whether_to_despawn_UG_MAPS_population() end
--     end
-- end)
--  axr_keybind.bind("DIK_NUMPAD2",function(p)
--     if p == 1 then
--         if enable_dbg then
-- -- local current_weather = level_weathers.get_weather_manager():get_curr_weather()
-- local current_weather = check_current_weather ()
-- if current_weather then
--     msg ( " ----- Current WEATHER: " .. current_weather )
-- end
-- end
-- end
-- end)

-- for performance optimization, per each map; goal: one CPU core utilized, (25% util. on 4core max), stable, stutter-free 40 FPS
-- UPDATE: past v1.35, all aboveground masp are populated together, ( less_freq_visited maps were populated every 4th day, previously )
-- to 'compensate', decrease their coeff here, by 4
-- 7 less_freq_visited maps: "theChernobylNPP(North)", "theChernobylNPP(South)", "Limansk", "theHospital", "theMeadow", "Yantar", "theGenerators"
-- these 7 UG maps have a spawn_function for them separately
-- "LabX-18" "thetunnelsunderAgroprom" "thePripyatUnderground" "LabX-8" "_dyn_news_l08u_brainlab" "LabX-19" "theMonolithWarLab"
local map_optimized_coeff = {
    ["Zaton"] = 0.11, -- 0.12
    ["Jupiter"] = 0.11, -- 0.12
    ["DarkValley"] = 0.24, -- 0.25
    ["Agroprom"] = 0.12,
    ["theGarbage"] = 0.2,
    ["Yantar"] = 0.225, -- Yantar seems good as is
    ["DeadCity"] = 0.17,
    ["Limansk"] = 0.1875, -- "Mortal Sin" is action-heavy chapter here, '/2' should provide a bit better performance in this instance
    ["RedForest"] = 0.40,
    ["theTruckCemetery"] = 0.25,
    ["theGenerators"] = 0.2375,
    ["theArmyWarehouses"] = 0.58, -- 0.63
    ["Radar"] = 0.9,
    ["theChernobylNPP(North)"] = 0.135, -- /5 -- largest maps in the Zone, with the most rec_pos,
    ["theChernobylNPP(South)"] = 0.128, -- an additional '/5' should keep performance good, even at ~1500 mutant_numbers
    ["Pripyat"] = 0.25, -- UPDATE: this greatly decreases the 'influx' of new mutants with each 'wave', so, incrase the global percentage a bit
    ["ontheoutskirtsofPripyat"] = 0.20,
    ["Darkscape"] = 0.92,
    ["Cordon"] = 0.55,
    ["theGreatSwamp"] = 0.25,
    ["Rostok"] = 0.55,
    ["theWildTerritory"] = 0.50,
    ["theMeadow"] = 0.25, -- Meadows seems good as is
    ["theHospital"] = 0.25,
}

function get_current_map_optimized_coeff(map_pos)
    -- for 'custom' PERCENTAGE for some maps
    return map_optimized_coeff[map_pos] or 1
end
-- this function takes a LEVEL.NAME() of the current map, and checks whether it is one of the SPCIFIC_LOCATIONS maps
-- 'skips' the translation_to_ENG this way

--  zaton jupiter dead city army warehouses truck cemetery meadows Radar
local spec_loc_map = {
    ["zaton"] = true,
    ["jupiter"] = true,
    ["l09_deadcity"] = true,
    ["l07_military"] = true,
    ["k02_trucks_cemetery"] = true,
    ["y04_pole"] = true,
    ["l10_radar"] = true
}

local function is_it_SPEC_LOC_map(current_map)
    return spec_loc_map[current_map]
end
-- this function takes a LEVEL.NAME() of the current map, and checks whether it is one of the UG maps
-- 'skips' the translation_to_ENG this way

-- ENG names: (map_pos == "LabX-18") or (map_pos == "thetunnelsunderAgroprom") or (map_pos == "thePripyatUnderground") or (map_pos == "LabX-8") or (map_pos == "_dyn_news_l08u_brainlab") or (map_pos == "LabX-19") or (map_pos == "theMonolithWarLab")
--  Dark Valley UG lab Agro_UG Jupiter_UG Outskirts Yantar, MM Radar theMonolithWarLab
local ug_map = {
    ["l04u_labx18"] = true,
    ["l03u_agr_underground"] = true,
    ["jupiter_underground"] = true,
    ["labx8"] = true,
    ["l08u_brainlab"] = true,
    ["l10u_bunker"] = true,
    ["l13u_warlab"] = true
}
local function is_it_UG_map(current_map)
    return ug_map[current_map]
end

-- this function takes an ENGLISH name of a map, and checks whether is one of the UG maps
-- suitable for the 'extracted' ENG names from the recorded positions
local ig_map = {
    ["LabX-18"] = true,
    ["thetunnelsunderAgroprom"] = true,
    ["thePripyatUnderground"] = true,
    ["LabX-8"] = true,
    ["_dyn_news_l08u_brainlab"] = true,
    ["LabX-19"] = true,
    ["theMonolithWarLab"] = true
}

local function is_it_UG_map_ENG_NAME(map_pos)
    return ig_map[map_pos]
end

-- this function takes an ENGLISH name of a map, and checks whether is one of the less_frequently_visited maps
-- suitable for the 'extracted' ENG names from the recorded positions

local less_freq_map = {
    ["theChernobylNPP(North)"] = true,
    ["theChernobylNPP(South)"] = true,
    ["Limansk"] = true,
    ["theHospital"] = true,
    ["theMeadow"] = true,
    ["Yantar"] = true,
    ["theGenerators"] = true
}

function is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos)
    return less_freq_map[map_pos]
end

local function clean_out_table_from_nonmatching_ids_vs_field_contents(table_to_clean_out)
    local id_check = 0
    for iii = 1, 65534 do
        id_check = iii
        if (table_to_clean_out[id_check]) then -- if that table field is not empty
            if (string_match(table_to_clean_out[id_check], id_check)) then -- if true, it is a correct entry ID/name
                -- if " table [45589] = "boar_weak45589"", original entry <-- keep it, no change
                -- msg ( " --- MATCH - %c[yellow]" .. table_to_clean_out[id_check] .. "%c[default] -- Table field number: %c[yellow]" .. id_check .. "%c[default] Entry: %c[yellow]" .. table_to_clean_out[id_check] )
                -- UPDATE: this is not really necessary
                -- when counting table-fields, it also checks whether the Alife exists
                -- and that same field-ID can be overwritten in the table, if it is actually 'free' and assigned to something else
                if (not alife_object(id_check)) then -- check if the Alife held in the field exists/alive
                -- if dead currently, empty the field, it is correct, but it points to a non-existing Alife
                -- msg ( " ------ CLEAN OUT -- correct FIELD with a NON-existent alife: " .. table_to_clean_out[id_check] .. " " .. id_check )
                -- table_to_clean_out[id_check] = nil
                end
            else
                -- if " table [45589] = "boar_weak27589" ", impostor <-- empty that table field
                msg(
                    " ------ IMPOSTOR removed -- Table field number: %c[yellow]" ..
                        id_check .. "%c[default] Entry: %c[yellow]" .. table_to_clean_out[id_check]
                )
                table_to_clean_out[id_check] = nil
            end
        end
    end
    return table_to_clean_out -- this table is a 're-vised' version of the starting one,
    -- with 'emptied' all fields that contain an entry that doesn't 'match' the table-number
    -- i.e. if table [45589] = "boar_weak27589" --> 'empty' that field, it doesn't belong in the table
    -- if table [45589] = "boar_weak45589" --> keep the entry, it is originally spawned as is
    -- NOTE/REMINDER: an ID is assigned to an object when spawned, BUT, if that 'object' dies off, the same ID can be assigned to something else
    -- as a result, the same ID can 'hold' link to a different object than the original
end
----- ================================================================================================================= ------
-- takes a table with IDs-names and it counts the number of entries
-- NOTE: #table doesn't returns 0, if used in this format table[45589] = "boar_weak45589"

local function __count_correct_ids_in_table__(temp_table)
    local EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = 0
    for iii = 1, 65534 do
        if (temp_table[iii]) and (alife_object(iii)) then
            EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = EXISTING_MUTANT_IDS_IN_TABLE_COUNTER + 1
        end
    end
    return EXISTING_MUTANT_IDS_IN_TABLE_COUNTER
end

local function count_mutant_ids_in_table()
    MUTANT_IDS_IN_A_TABLE = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)
    MUTANT_IDS_IN_A_TABLE_UG = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE_UG)
    MUTANT_IDS_IN_A_TABLE_SPEC_LOC =
        clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE_SPEC_LOC)
    msg(" ---------------- MUTANT_IDS_IN_A_TABLE: " .. __count_correct_ids_in_table__(MUTANT_IDS_IN_A_TABLE))
    msg(" ----------- MUTANT_IDS_IN_A_TABLE_UG: " .. __count_correct_ids_in_table__(MUTANT_IDS_IN_A_TABLE_UG))
    msg(
        " ----------- MUTANT_IDS_IN_A_TABLE_SPEC_LOC: " ..
            __count_correct_ids_in_table__(MUTANT_IDS_IN_A_TABLE_SPEC_LOC)
    )
end
-- to get the same number of days you get in the PDA - Statistics.

local function get_time_elapsed_from_new_game_start()
    local s_time = level.get_start_time()
    local seconds = tonumber(game.get_game_time():diffSec(s_time))
    return math_floor(seconds / 86400)
end
-- and double-check beforehand whether it is actually a mutant

function despawn_existing_mutants_in_table()
    -- clearing out the table from fields/mutant_names that are not included in the main spawn
    MUTANT_IDS_IN_A_TABLE = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)
    -- afterwards, check again before despawning them, just in case
    local id_check = 0
    local EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = 0
    local FOUND_MATCH_IN_TABLE = false
    local ___FILTERED_OBJECTS_MUTANT_NAMES___ = ___MUTANT_IDS_IN_A_TABLE_MAIN__INCLUDED_MUTANT_NAMES___
    local DESPAWNED_MUTANTS_NUMBER = 0
    MUTANT_IDS_IN_A_TABLE = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)
    local sim = alife()
    for iii = 1, 65534 do
        id_check = iii
        if (id_check) and (alife_object(id_check)) and MUTANT_IDS_IN_A_TABLE[id_check] then
            if (string_match(MUTANT_IDS_IN_A_TABLE[id_check], id_check)) then
                -- msg ( " ----- DESPAWNED MAIN Mutant: " .. MUTANT_IDS_IN_A_TABLE [id_check] .. " " .. id_check )
                sim:release(sim:object(id_check)) -- to remove mutants on multiple maps
                DESPAWNED_MUTANTS_NUMBER = DESPAWNED_MUTANTS_NUMBER + 1
            else
                -- msg ( " ------- CLEARED MAIN field: " .. MUTANT_IDS_IN_A_TABLE [id_check] .. " " .. id_check )
                MUTANT_IDS_IN_A_TABLE[id_check] = nil
            end
        end
    end
    -- main mutants are now not present in the table, anything that (eventually) remains, is something else
    --- so, re-set the table and the counter, to start filling it with new entries
    MUTANT_IDS_IN_A_TABLE = {}
    msg(" ----------- DESPAWNED_MUTANTS_NUMBER: " .. DESPAWNED_MUTANTS_NUMBER)
    despawn_ambiental_fauna()
end

function despawn_ambiental_fauna()
    local AMB_FAUNA = {
        "dog_shepherd",
        "fox_red",
        "m_crow_default",
        "m_crow_bigger",
        "m_crow_big",
        "m_crow_largest",
        "chicken_"
    }
    local id_check = 0
    local FOUND_MATCH_IN_TABLE = false
    local ___FILTERED_OBJECTS_MUTANT_NAMES___ = AMB_FAUNA -- contains the mutant_names that need to be removed
    -- for iii=1,#MUTANT_IDS_IN_A_TABLE do
    -- id_check = MUTANT_IDS_IN_A_TABLE [iii]
    local sim = alife()
    for iii = 1, 65534 do
        id_check = iii
        if (id_check) then
            if (alife_object(id_check)) then
                FOUND_MATCH_IN_TABLE = false -- start doing a 'match' vs the table_data, when a match is found, 'FOUND_MATCH_IN_TABLE' will be true
                -- iterate all mutant names ( VS the current object_ID_name )
                for n = 1, #___FILTERED_OBJECTS_MUTANT_NAMES___ do
                    -- i.e. if didn't had a match yet
                    if alife_object(id_check) and (FOUND_MATCH_IN_TABLE == false) then -- some IDs (1-65534) do not contain an object
                        if (___FILTERED_OBJECTS_MUTANT_NAMES___[n] ~= nil) then -- if the table field is not nil
                            if (string_match(alife_object(id_check):name(), ___FILTERED_OBJECTS_MUTANT_NAMES___[n])) then
                                sim:release(sim:object(id_check)) -- to remove mutants on multiple maps
                                FOUND_MATCH_IN_TABLE = true -- found a match, exit the current 'for to, table' cycle
                            end
                        end
                    end
                end
            end
        end
    end
end

function append_tables(table1, table2)
    local table1_start_entries_number = #table1
    for i = 1, #table2 do
        table1[table1_start_entries_number + i] = table2[i]
    end
    -- now, the fields in the TABLE2 should be added at the end of the TABLE1
    return table1
end
-- to remove the birds when the Player sleeps

function count_additional_birds()
    local id_check = 0
    local FOUND_MATCH_IN_TABLE = false
    local ___FILTERED_OBJECTS_MUTANT_NAMES___ = {"m_crow_default", "m_crow_bigger", "m_crow_big", "m_crow_largest"} -- "m_crow",
    local COUNT_ADDIT_BIRDS_NUMBER = 0
    for i = 1, 65534 do
        id_check = i
        if (id_check) then
            if (alife_object(id_check)) then
                FOUND_MATCH_IN_TABLE = false -- start doing a 'match' vs the table_data, when a match is found, 'FOUND_MATCH_IN_TABLE' will be true
                -- iterate all mutant names ( VS the current object_ID_name )
                for n = 1, #___FILTERED_OBJECTS_MUTANT_NAMES___ do
                    -- i.e. if didn't had a match yet
                    if alife_object(id_check) and (FOUND_MATCH_IN_TABLE == false) then -- some IDs (1-65534) do not contain an object
                        if (string_match(alife_object(id_check):name(), ___FILTERED_OBJECTS_MUTANT_NAMES___[n])) then
                            ----------------------------------------------------------------------------------
                            -- IMPORTANT NOTE: if/when 'matching' for "m_crow", it MAY find "lim_crow_spawn_ " also
                            -- so, before despawning, check for and omit any of these findings
                            -- if ( not string_match ( alife_object(id_check):name() , "lim_crow_spawn" ) ) then
                            -- msg ( " --- EXISTING ADDIT BIRD: " .. alife_object(id_check):name() )
                            -- alife():release( alife():object( id_check ) ) -- to remove mutants on multiple maps
                            COUNT_ADDIT_BIRDS_NUMBER = COUNT_ADDIT_BIRDS_NUMBER + 1
                            FOUND_MATCH_IN_TABLE = true -- found a match, exit the current 'for to, table' cycle
                        -- end
                        ----------------------------------------------------------------------------------
                        end
                    end
                end
            end
        end
    end
    return COUNT_ADDIT_BIRDS_NUMBER
end
-- to remove the birds when the Player sleeps
-- --> local current_numbers__german_chepherd__fox__chicken = count_currently_existing_german_shepherds_foxes_chickens ()
-- will get a table, with three fields, containing the numbers

function count_currently_existing_german_shepherds_foxes_chickens()
    local id_check = 0
    local COUNT_GERMAN_SHEPHERDS_NUMBER = 0
    local COUNT_FOXES_NUMBER = 0
    local COUNT_CKICKENS_NUMBER = 0
    for i = 1, 65534 do
        id_check = i
        if (id_check) then
            if (alife_object(id_check)) then
                if (string_match(alife_object(id_check):name(), "dog_shepherd")) then
                    COUNT_GERMAN_SHEPHERDS_NUMBER = COUNT_GERMAN_SHEPHERDS_NUMBER + 1
                end
                if (string_match(alife_object(id_check):name(), "fox_red")) then
                    COUNT_FOXES_NUMBER = COUNT_FOXES_NUMBER + 1
                end
                if (string_match(alife_object(id_check):name(), "chicken")) then
                    COUNT_CKICKENS_NUMBER = COUNT_CKICKENS_NUMBER + 1
                end
            end
        end
    end
    local numbers = {COUNT_GERMAN_SHEPHERDS_NUMBER, COUNT_FOXES_NUMBER, COUNT_CKICKENS_NUMBER}
    return numbers
end
-- will remove all (additional mutants that are not selected) existing in the Zone, ID = 1 to 65535
-- NOTE: this process takes ~1 second, (when all addit. mutants are unselected)
-- it is done when the Player doesn't yet have control over the character, so it is not an issue
-- NOTE2: the whole 'spawn_wave' + the 'removal of unselected addit.mutants' after it, takes around 1.5 seconds

function remove_unselected_additional_mutants()
    local temp_table = {} -- we'll be gathering the necessary mutant_names here
    local VOLK_NAMES = {"mwolf"}
    local MEDVED_NAMES = {"medved"}
    local TARK_NAMES = {"tark"}
    local PIRANHA_NAMES = {"piranha_"}
    local SHEPHERD_FOX_BIRDS_NAMES = {
        "dog_shepherd",
        "fox_red",
        "m_crow_default",
        "m_crow_bigger",
        "m_crow_big",
        "m_crow_largest",
        "chicken_"
    }
    local MONSTER_BOAR_NAMES = {"boar_big_monster"}
    local VENDIGO_NAMES = {"vendigo"}
    local MISC_NAMES_TO_ALSO_REMOVE = {"poltergeist_build"} -- to remove them IF the main checkbox is unselected
    -- collect all mutant_names (that are not selected) in a table ('strings' to match in the name)
    if (dyn_mutants_enable_volk == false) then
        temp_table = append_tables(temp_table, VOLK_NAMES)
    end
    if (dyn_mutants_enable_medved == false) then
        temp_table = append_tables(temp_table, MEDVED_NAMES)
    end
    if (dyn_mutants_enable_tark == false) then
        temp_table = append_tables(temp_table, TARK_NAMES)
    end
    if (dyn_mutants_enable_piranha == false) then
        temp_table = append_tables(temp_table, PIRANHA_NAMES)
    end
    if (dyn_mutants_enable_shepherd_fox_birds == false) then
        temp_table = append_tables(temp_table, SHEPHERD_FOX_BIRDS_NAMES)
    end
    if (dyn_mutants_enable_monster_boar == false) then
        temp_table = append_tables(temp_table, MONSTER_BOAR_NAMES)
    end
    if (dyn_mutants_enable_vendigo == false) then
        temp_table = append_tables(temp_table, VENDIGO_NAMES)
    end
    if (dyn_mutants_enable_all_additional_mutants == false) then
        temp_table = append_tables(temp_table, MISC_NAMES_TO_ALSO_REMOVE)
    end
    --[[ -- a check
msg ( " -- " .. #temp_table )
msg ( " ----------- NAMES of UNSELECTED MUTANTS: " )
for i=1, #temp_table do
if ( temp_table[i] ~= nil ) then -- if the table field is not nil
msg ( " ---- " .. temp_table[i] )
msg ( " -- " .. i )
end
end
-- msg ( " ----------- DESPAWNED_MUTANTS_NUMBER: " .. DESPAWNED_MUTANTS_NUMBER )
--]]
    ---[[
    local id_check = 0
    local EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = 0
    local FOUND_MATCH_IN_TABLE = false
    local ___FILTERED_OBJECTS_MUTANT_NAMES___ = temp_table -- contains the mutant_names that need to be removed
    local DESPAWNED_MUTANTS_NUMBER = 0
    -- for iii=1,#MUTANT_IDS_IN_A_TABLE do
    -- id_check = MUTANT_IDS_IN_A_TABLE [iii]
    -- this is to remove any existing instances of the additional mutants that are not selected/enabled
    local sim = alife()
    for iii = 1, 65534 do
        id_check = iii
        if (id_check) then
            if (alife_object(id_check)) then
                FOUND_MATCH_IN_TABLE = false -- start doing a 'match' vs the table_data, when a match is found, 'FOUND_MATCH_IN_TABLE' will be true
                -- iterate all mutant names ( VS the current object_ID_name )
                for n = 1, #___FILTERED_OBJECTS_MUTANT_NAMES___ do
                    -- i.e. if didn't had a match yet
                    if alife_object(id_check) and (FOUND_MATCH_IN_TABLE == false) then -- some IDs (1-65534) do not contain an object
                        if (___FILTERED_OBJECTS_MUTANT_NAMES___[n] ~= nil) then -- if the table field is not nil
                            if (string_match(alife_object(id_check):name(), ___FILTERED_OBJECTS_MUTANT_NAMES___[n])) then
                                -- news_manager.send_tip(db.actor, " --- DESPAWNED MUTANT: " .. alife_object(id_check):name() , nil, nil, 10000 )
                                sim:release(sim:object(id_check)) -- to remove mutants on multiple maps
                                DESPAWNED_MUTANTS_NUMBER = DESPAWNED_MUTANTS_NUMBER + 1
                                FOUND_MATCH_IN_TABLE = true -- found a match, exit the current 'for to, table' cycle
                            end
                        end
                    end
                end
            end
        end
    end
    -- news_manager.send_tip(db.actor, " ----------- DESPAWNED_ADDIT_MUTANTS_NUMBER: " .. DESPAWNED_MUTANTS_NUMBER , nil, nil, 10000 )
    --]]

    --Kill em all if checked
    if ui_mcm and (ui_mcm.get("dynamic_mutants/dyn_mutants_kill_em_all") or ui_mcm.get("dynamic_mutants/dyn_mutants_kill_dyn_mutants") or ui_mcm.get("dynamic_mutants/dyn_mutants_kill_new_dyn_mutants")) then
        local sim = alife()
        local count = 0

        local kill_new_mutants = ui_mcm.get("dynamic_mutants/dyn_mutants_kill_new_dyn_mutants")
        local kill_dyn_mutants = ui_mcm.get("dynamic_mutants/dyn_mutants_kill_dyn_mutants")
        local kill_em_all = ui_mcm.get("dynamic_mutants/dyn_mutants_kill_em_all")

        MUTANT_IDS_IN_A_TABLE = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)
        for i=1,65534 do
            local se_obj = sim:object(i)
            if se_obj then
                local section_name = se_obj:section_name()
                if
                    (kill_em_all and not item_table[section_name] and (monster_names[section_name] or IsMonster(se_obj, nil)))
                    or
                    (kill_dyn_mutants and not item_table[section_name] and (monster_names[section_name] or (IsMonster(se_obj, nil) and MUTANT_IDS_IN_A_TABLE[i] and string_match(MUTANT_IDS_IN_A_TABLE[i], i))))
                    or
                    (kill_new_mutants and monster_names[section_name])
                then
                    printf("released monster id %s, section %s", i, section_name)
                    count = count + 1
                    sim:release(se_obj)
                end
            end
        end

        MUTANT_IDS_IN_A_TABLE = (kill_dyn_mutants or kill_em_all) and {} or clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)

        --print_r(MUTANT_IDS_IN_A_TABLE)

        news_manager.send_tip(db.actor, "Killed %c[yellow]" .. count .. "%c[default] mutants in the Zone", nil, nil, 10000)
        printf("killed monsters: %s", count)
        ui_mcm.set("dynamic_mutants/dyn_mutants_kill_em_all", false)
        ui_mcm.set("dynamic_mutants/dyn_mutants_kill_dyn_mutants", false)
        ui_mcm.set("dynamic_mutants/dyn_mutants_kill_new_dyn_mutants", false)
    end
end

function set_first_start_timestamp()
    -- check for the 'marker', i.e. whether the objects have already been spawned
    if not (has_alife_info("first_start_timestamp_is_set_dyn_mut")) then
        timestamp_when_playthrough_started_in_days = level.get_time_days()
        give_info("first_start_timestamp_is_set_dyn_mut") -- set the 'marker'
    end
end
-- "pri_a28_earth_helli_2" - the heli all positions, on all maps, regardless of percentage and safe_distance
-- for testing purposes, will instead spawn a HELICOPTER at each position, (to indicate them more clearly) (in case some more positions need to be added)
--[[
axr_keybind.bind("DIK_ADD",function(p)
if p == 1 then
-- spawn_dynamic_mutants_ TEST_HELICOPTER()
local HELIS_on_rodent_positions = true -- false --
local HELIS_on_fleshes_boars_positions = true -- false --
local HELIS_on_zombies_fractures_positions = true -- false --
local HELIS_on_bloodsuckers_positions = true -- false --
local HELIS_on_chimera_giant_positions = true -- false --
local ini = ini_file("plugins\\____gather_position_data_MUTANTS_RODENTS.ltx")
local n = ini:line_count("DYNAMIC_MUTANTS")
-- start the 'cycle' of going through all the recorded_positions
for k=0,n-1 do
local result,i,v = ini:r_line_ex("DYNAMIC_MUTANTS",k)
local tp = v and str_explode(v,",")
local pos = vector():set(tonumber(tp[1]),tonumber(tp[2]),tonumber(tp[3]))
local lid = tonumber(tp[4])
local gid = tonumber(tp[5])
-- from the RODENTS_positions is 'enough', they will (mostly) contain all the maps
----------------------------------------------------------------------
-- to add the current recorded_position map_name in a file
position_file = "gamedata\\__GATHER_TEMP_DEVELOPMENT_DATA.ltx"
local function write_file(text,...)
if not text then return end
local debug_file = io.open(position_file,"a+")
if ( debug_file == nil ) then
debug_mode = false
return
end
local i = 0
local p = {...}
local function sr(a)
i = i + 1
return tostring(p[i])
end
local output = string_gsub(text,"%%s",sr)
debug_file:write(output.."\n\n")
debug_file:close()
exec_console_cmd("load ~#I#:"..output)
end
write_file("Map name: '%s'", string_sub(tp[8], 12), dynamic_news_helper.GetPointDescription(db.actor) or "")
write_file("","")
position_file = nil
----------------------------------------------------------------------
if (IDs_utilized_current_number < 55000) and HELIS_on_rodent_positions then local se = alife():create("pri_a28_earth_helli_2",pos,lid,gid) end
end
-- end of the 'cycle' of going through all the recorded_positions
local ini = ini_file("plugins\\____gather_position_data_MUTANTS_BOAR_FLESH.ltx")
local n = ini:line_count("DYNAMIC_MUTANTS")
-- start the 'cycle' of going through all the recorded_positions
for k=0,n-1 do
local result,i,v = ini:r_line_ex("DYNAMIC_MUTANTS",k)
local tp = v and str_explode(v,",")
local pos = vector():set(tonumber(tp[1]),tonumber(tp[2]),tonumber(tp[3]))
local lid = tonumber(tp[4])
local gid = tonumber(tp[5])
if (IDs_utilized_current_number < 55000) and HELIS_on_fleshes_boars_positions then local se = alife():create("pri_a28_earth_helli_2",pos,lid,gid) end
end
-- end of the 'cycle' of going through all the recorded_positions
local ini = ini_file("plugins\\____gather_position_data_MUTANTS_ZOMBIES_FRACTURE.ltx")
local n = ini:line_count("DYNAMIC_MUTANTS")
-- start the 'cycle' of going through all the recorded_positions
for k=0,n-1 do
local result,i,v = ini:r_line_ex("DYNAMIC_MUTANTS",k)
local tp = v and str_explode(v,",")
local pos = vector():set(tonumber(tp[1]),tonumber(tp[2]),tonumber(tp[3]))
local lid = tonumber(tp[4])
local gid = tonumber(tp[5])
if (IDs_utilized_current_number < 55000) and HELIS_on_zombies_fractures_positions then local se = alife():create("pri_a28_earth_helli_2",pos,lid,gid) end
end
-- end of the 'cycle' of going through all the recorded_positions
local ini = ini_file("plugins\\____gather_position_data_MUTANTS_BLOODSUCKER.ltx")
local n = ini:line_count("DYNAMIC_MUTANTS")
-- start the 'cycle' of going through all the recorded_positions
for k=0,n-1 do
local result,i,v = ini:r_line_ex("DYNAMIC_MUTANTS",k)
local tp = v and str_explode(v,",")
local pos = vector():set(tonumber(tp[1]),tonumber(tp[2]),tonumber(tp[3]))
local lid = tonumber(tp[4])
local gid = tonumber(tp[5])
if (IDs_utilized_current_number < 55000) and HELIS_on_bloodsuckers_positions then local se = alife():create("pri_a28_earth_helli_2",pos,lid,gid) end
end
-- end of the 'cycle' of going through all the recorded_positions
local ini = ini_file("plugins\\____gather_position_data_MUTANTS_CHIMERA_GIANT.ltx")
local n = ini:line_count("DYNAMIC_MUTANTS")
-- start the 'cycle' of going through all the recorded_positions
for k=0,n-1 do
local result,i,v = ini:r_line_ex("DYNAMIC_MUTANTS",k)
local tp = v and str_explode(v,",")
local pos = vector():set(tonumber(tp[1]),tonumber(tp[2]),tonumber(tp[3]))
local lid = tonumber(tp[4])
local gid = tonumber(tp[5])
if (IDs_utilized_current_number < 55000) and HELIS_on_chimera_giant_positions then local se = alife():create("pri_a28_earth_helli_2",pos,lid,gid) end
end
-- end of the 'cycle' of going through all the recorded_positions
ini = nil
k = nil
n = nil
m = nil
v = nil
tp = nil
end -- <-- 'end' to close the 'if p == 1 then'
end)
--]]
-- for testing purposes, NUMPAD_DIVIDE reveals the time till next mutant 'wave', in days
---[[
axr_keybind.bind(
    "DIK_DIVIDE",
    function(p)
        if p == 1 then
            set_max_numbers_limit()
            -- check the table/data with stored IDs about existing mutants, count their numbers, etc
            local id_check = 0
            local EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = 0
            local DEAD_MUTANT_IDS_IN_TABLE_COUNTER = 0
            MUTANT_IDS_IN_A_TABLE = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)
            for iii = 1, 65534 do
                id_check = iii
                if (id_check) and (alife_object(id_check)) and (MUTANT_IDS_IN_A_TABLE[id_check]) then
                    if (string_match(MUTANT_IDS_IN_A_TABLE[id_check], id_check)) then
                        EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = EXISTING_MUTANT_IDS_IN_TABLE_COUNTER + 1
                    else
                        MUTANT_IDS_IN_A_TABLE[iii] = nil
                        DEAD_MUTANT_IDS_IN_TABLE_COUNTER = DEAD_MUTANT_IDS_IN_TABLE_COUNTER + 1
                    end
                end
            end
            -- ==> now, EXISTING_MUTANT_IDS_IN_TABLE_COUNTER contain the exact number of currently existing DynMutants , (all thr. the Zone)
            -- LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON contains the NUMBER_LIMIT that the DynMutant numbers need to be close to.
            MUTANT_IDS_IN_A_TABLE = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)
            EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = __count_correct_ids_in_table__(MUTANT_IDS_IN_A_TABLE)
            -- calculate the difference  ( if positive --> continue adding mutants next day; if negative --> wait for culling of mutants )
            local CURRENT_NUMBERS_to_LIMIT_NUMBER_DIFFERENCE =
                LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON * LIMIT_COEFFICIENT - EXISTING_MUTANT_IDS_IN_TABLE_COUNTER
            if (CURRENT_NUMBERS_to_LIMIT_NUMBER_DIFFERENCE > 0) then
                ENOUGH_MUTANTS_CULLED = true
            else
                ENOUGH_MUTANTS_CULLED = false
            end
            local current_game_time = utils_data.CTimeToSec(game.get_game_time()) / 3600 / 24 -- in-game DAYS from NEW_START
            -- if an EMISSION 'messes up' the 'last_time_to_spawn_dynamic_mutants' time stamp, re-'set' it by ' = current_game_time'
            if (current_game_time < last_time_to_spawn_dynamic_mutants) then
                last_time_to_spawn_dynamic_mutants = current_game_time
            end
            local time_until_next_attack =
                next_time_to_spawn_dynamic_mutants - (current_game_time - last_time_to_spawn_dynamic_mutants)
            --[[ -- UPDATE> separated messages look better.
------------------------
-- concatenating all info into a single PDA message, separated by .. game.translate_string("NEWLINE")
-- will need the .XML file also
local NEXT_WAVE_IN_DAYS_line = ""
if ( (time_until_next_attack < 0) and (ENOUGH_MUTANTS_CULLED) ) then -- necessary TIME_INTERVAL has passed AND mutant numbers are culled enough
NEXT_WAVE_IN_DAYS_line = string.format( "Next potential 'wave' in: %s days. ..PENDING: travel to another map..%s", tonumber(string.format("%.3f", time_until_next_attack)), game.translate_string("NEWLINE") )
elseif ( time_until_next_attack < 0 ) then -- ONLY necessary TIME_INTERVAL has passed; waiting for mutant numbers culling enough
NEXT_WAVE_IN_DAYS_line = string.format( "Next potential 'wave' in: %s days. ..PENDING: culling of %s more mutants..%s", tonumber(string.format("%.3f", time_until_next_attack)), CURRENT_NUMBERS_to_LIMIT_NUMBER_DIFFERENCE, game.translate_string("NEWLINE") )
else -- waiting for necessary TIME_INTERVAL to pass; usually between 3-5 days
NEXT_WAVE_IN_DAYS_line = string.format( "Next potential 'wave' in: %s days.%s", tonumber(string.format("%.3f", time_until_next_attack)), game.translate_string("NEWLINE") )
end
local TOTAL_NUMBER_OF_MUTANTS_ADDED_line = string.format( "TOTAL NUMBER of MUTANTS ADDED: %s days.%s", tonumber(string.format("%.3f", time_until_next_attack)), game.translate_string("NEWLINE") )
local LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON_line = string.format( "LIMIT on MUTANTS ADDED by THIS ADDON: %s days.%s", LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON, game.translate_string("NEWLINE") )
local NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE_line = string.format( "MUTANTS ADDED in LAST_WAVE: %s %s", NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE, game.translate_string("NEWLINE") )
local ARE_ENOUGH_MUTANTS_CULLED_line = ""
if ( (time_until_next_attack < 0) and (ENOUGH_MUTANTS_CULLED) ) then -- necessary TIME_INTERVAL has passed AND mutant numbers are culled enough
ARE_ENOUGH_MUTANTS_CULLED_line = string.format( "Next 'wave' in: %6d days. ..PENDING: travel to another map..%s", tonumber(string.format("%.3f", time_until_next_attack)), game.translate_string("NEWLINE") )
elseif ( time_until_next_attack < 0 ) then -- ONLY necessary TIME_INTERVAL has passed; waiting for mutant numbers culling enough
ARE_ENOUGH_MUTANTS_CULLED_line = string.format( "Next 'wave' in: %6d days. ..PENDING: culling of %s more mutants..%s", tonumber(string.format("%.3f", time_until_next_attack)), NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE-MUTANTS_DEAD_COUNT, game.translate_string("NEWLINE") )
else -- waiting for necessary TIME_INTERVAL to pass; usually between 3-5 days
ARE_ENOUGH_MUTANTS_CULLED_line = string.format( "Next 'wave' in: %6d days.%s", tonumber(string.format("%.3f", time_until_next_attack)), game.translate_string("NEWLINE") )
end
local FULL_PDA_MESSAGE = NEXT_WAVE_IN_DAYS_line .. TOTAL_NUMBER_OF_MUTANTS_ADDED_line .. LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON_line .. NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE_line .. ARE_ENOUGH_MUTANTS_CULLED_line
news_manager.send_tip(db.actor, FULL_PDA_MESSAGE , nil, nil, 10000 )
------------------------
--]]
            -- count the TOTAL number of EXISTING MUTANTS, ( i.e. those from Anomaly + those from the DynMutants addon )
            -- and afterwards, show PDA messages with the infos
            ---------------------------------------------------------------------------
            -- to go through all 65536 IDs, and to find those which names contain a specific string,
            -- (contained in one of the fields in the '___FILTERED_OBJECTS_IDS_TO_DO_STUFF_TO___' table)
            -- CAUTION: takes 0.5-1 second to process this
            -- NOTE: by changing the data in the table, (or the table itself),
            -- you can specifically 'process' only chosen group of objects. (ex: stalkers, mutants, 'bmb' anomalies to delete)
            -- local ___FILTERED_OBJECTS_IDS_TO_DO_STUFF_TO___ = { "flesh", "bloodsucker", "dog", "boar", "giant", "controller", "poltergeist", "snork", "crow", "tushkano", "phantom", "chimera", "burer", "borya", "zombi_", "zombie_", "fracture", "cat", "rat", "bibliotekar", "karlik", "lurker", "psysucker", "gigant", "piranha", "rotan", "_crow_", "mwolf", "medved", "tark", "fly" }
            local ___FILTERED_OBJECTS_IDS_TO_DO_STUFF_TO___ = {
                "flesh",
                "bloodsucker",
                "dog",
                "boar",
                "snork",
                "tushkano",
                "chimera",
                "burer",
                "zombi_",
                "zombie_",
                "fracture",
                "cat",
                "rat",
                "lurker",
                "piranha",
                "crow",
                "mwolf",
                "medved",
                "tark",
                "gigant",
                "psysucker",
                "poltergeist",
                "controller",
                "karlik",
                "borya",
                "phantom"
            }
            -- added the new mutants to count them as mutants also
            local total_number_of_objects_found = 0
            local FOUND_MATCH_IN_TABLE = false
            --[[
-- iterate all ID numbers, takes around 4 seconds (at most: 1-65k IDs; 1-26 mutant names)
for i=1, 65534 do
FOUND_MATCH_IN_TABLE = false -- start doing a 'match' vs the table_data, when a match is found, 'FOUND_MATCH_IN_TABLE' will be true
-- iterate all mutant names ( VS the current object_ID_name )
for n=1, #___FILTERED_OBJECTS_IDS_TO_DO_STUFF_TO___ do
-- i.e. if didn't had a match yet
if alife_object(i) and ( FOUND_MATCH_IN_TABLE == false ) then -- some IDs (1-65534) do not contain an object
-- check if object_name contains a string in the above table
if ( string_match ( alife_object(i):name() , ___FILTERED_OBJECTS_IDS_TO_DO_STUFF_TO___[n] ) ) then
total_number_of_objects_found = total_number_of_objects_found + 1 -- count up the found instances-success
FOUND_MATCH_IN_TABLE = true -- found a match, exit the current 'for to, table' cycle
end
end
end
end
---------------------------------------------------------------------------
--]]
            if ((time_until_next_attack < 0) and (ENOUGH_MUTANTS_CULLED)) then -- necessary TIME_INTERVAL has passed AND mutant numbers are culled enough
                news_manager.send_tip(
                    db.actor,
                    "Next potential 'wave' in: %c[yellow]" ..
                        tonumber(string.format("%.3f", time_until_next_attack)) ..
                            "%c[default] days. ..PENDING: travel to another map, or sleep.",
                    nil,
                    nil,
                    MESSAGE_DURATION * 1000
                )
            elseif (time_until_next_attack < 0) then -- ONLY necessary TIME_INTERVAL has passed; waiting for mutant numbers culling enough
                news_manager.send_tip(
                    db.actor,
                    "Next potential 'wave' in: %c[yellow]" ..
                        tonumber(string.format("%.3f", time_until_next_attack)) ..
                            "%c[default] days. ..PENDING: culling of " ..
                                -CURRENT_NUMBERS_to_LIMIT_NUMBER_DIFFERENCE .. " more mutants..",
                    nil,
                    nil,
                    MESSAGE_DURATION * 1000
                )
            else -- waiting for necessary TIME_INTERVAL to pass; usually between 3-5 days
                news_manager.send_tip(
                    db.actor,
                    "Next potential 'wave' in: %c[yellow]" ..
                        tonumber(string.format("%.3f", time_until_next_attack)) .. "%c[default] days",
                    nil,
                    nil,
                    MESSAGE_DURATION * 1000
                )
            end
            MUTANT_IDS_IN_A_TABLE = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)
            -- news_manager.send_tip(db.actor, "TOTAL NUMBER of MUTANTS ADDED: %c[yellow]" .. TOTAL_NUMBER_OF_MUTANTS_ADDED , nil, nil, MESSAGE_DURATION * 1000 )
            news_manager.send_tip(
                db.actor,
                "LIMIT on MUTANTS ADDED by THIS ADDON: %c[yellow]" .. LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON,
                nil,
                nil,
                MESSAGE_DURATION * 1000
            )
            -- news_manager.send_tip(db.actor, "MUTANTS ADDED in LAST_WAVE: %c[yellow]" .. MUTANT_IDS_IN_A_TABLE_COUNTER , nil, nil, MESSAGE_DURATION * 1000 ) -- previously, NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE
            news_manager.send_tip(
                db.actor,
                "CURRENTLY EXISTING MUTANTS (from DynMut addon): %c[yellow]" ..
                    __count_correct_ids_in_table__(MUTANT_IDS_IN_A_TABLE),
                nil,
                nil,
                MESSAGE_DURATION * 1000
            ) -- previously, NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE
            --[[
-------------------------------------- numbers from the UG and SPEC_LOC ----------------------------------------
----------------------- not needed, not calculating the total mutants number
local id_check = 0
local MUTANT_IDS_IN_A_TABLE_UG_COUNTER = 0
for iii=1,#MUTANT_IDS_IN_A_TABLE_UG do
id_check = MUTANT_IDS_IN_A_TABLE_UG [iii]
if ( id_check ) and ( alife_object(id_check) ) then -- if this mutant exists
MUTANT_IDS_IN_A_TABLE_UG_COUNTER = MUTANT_IDS_IN_A_TABLE_UG_COUNTER + 1
-- news_manager.send_tip(db.actor, " --------alife_object(id_check): " .. alife_object(id_check):name() , nil, nil, 10000 )
else
MUTANT_IDS_IN_A_TABLE_UG [iii] = nil -- remove dead mutants from the table fields
end
end
local id_check = 0
local MUTANT_IDS_IN_A_TABLE_SPEC_LOC_COUNTER = 0
for iii=1,#MUTANT_IDS_IN_A_TABLE_SPEC_LOC do
id_check = MUTANT_IDS_IN_A_TABLE_SPEC_LOC [iii]
if ( id_check ) and ( alife_object(id_check) ) then -- if this mutant exists
MUTANT_IDS_IN_A_TABLE_SPEC_LOC_COUNTER = MUTANT_IDS_IN_A_TABLE_SPEC_LOC_COUNTER + 1
-- news_manager.send_tip(db.actor, " --------alife_object(id_check): " .. alife_object(id_check):name() , nil, nil, 10000 )
else
MUTANT_IDS_IN_A_TABLE_SPEC_LOC [iii] = nil -- remove dead mutants from the table fields
end
end
-------------------------------------- numbers from the UG and SPEC_LOC ----------------------------------------
--]]
            -- the message containing the TOTAL NUMBER of EXISTING MUTANTS
            -- UPDATE: excluded this, needs too much processing to get an accurate number UPDATE-- can show ONLY mutants from Anomaly itself
            -- news_manager.send_tip(db.actor, "CURRENTLY EXISTING MUTANTS (from Anomaly itself): %c[yellow]" .. total_number_of_objects_found - EXISTING_MUTANT_IDS_IN_TABLE_COUNTER - MUTANT_IDS_IN_A_TABLE_UG_COUNTER - MUTANT_IDS_IN_A_TABLE_SPEC_LOC_COUNTER , nil, nil, MESSAGE_DURATION * 1000 ) -- previously, NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE
            -- ^^ - the TOTAL NUMBER of EXISTING MUTANTS
            if (ENOUGH_MUTANTS_CULLED) then -- mutant numbers are culled enough
                -- news_manager.send_tip(db.actor, "MUTANTS DEAD since LAST_WAVE: " .. MUTANTS_DEAD_COUNT , nil, nil, MESSAGE_DURATION * 1000 )
            else -- mutant numbers need culling
                -- news_manager.send_tip(db.actor, "MUTANTS DEAD since LAST_WAVE: " .. MUTANTS_DEAD_COUNT .. " (need: " .. NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE .. ")" , nil, nil, MESSAGE_DURATION * 1000 )
                news_manager.send_tip(
                    db.actor,
                    "NEEDS CULLING of %c[yellow]" ..
                        -CURRENT_NUMBERS_to_LIMIT_NUMBER_DIFFERENCE ..
                            "%c[default] more mutants, before it adds new ones",
                    nil,
                    nil,
                    MESSAGE_DURATION * 1000
                )
            end
            -- to get the number of 'GameObjects ID' utilized, ( ... to do not add/spawn new mutants if it is > 55.000 )
            -- NOTE: this function finishes in less than 100ms, but it creates a minor stutter
            ---- so, execute it when a level is loaded, RegisterScriptCallback("on_level_changing"), and save the number in a GLOBAL VAR
            local IDs_utilized_current_number = 0
            local sim = alife()
            for i = 1, 65534 do
                local se_obj = sim:object(i)
                if (se_obj) then
                    IDs_utilized_current_number = IDs_utilized_current_number + 1
                end
            end
            news_manager.send_tip(
                db.actor,
                "IDs utilized: %c[yellow]" .. IDs_utilized_current_number,
                nil,
                nil,
                MESSAGE_DURATION * 1000
            )
        end
    end
)
--]]
-- these are calculated: "actor_on_first_update" and when menu_settings are changed
-- global vars, save/load in the savegame also

function set_max_numbers_limit()
    -- to work with U4H8, which cannot set this value in-game in the settings
    LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON = dyn_mutants_target_numbers -- or LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON_DEFAULT
    -- NOTE: PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT ( =15) <-- the default value, set above in the var,
    -- corresponds with value of 1000 ( selected 'dyn_mutants_target_numbers' )
    if (LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON >= 2500) then
        PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT * 1.55
    elseif (LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON >= 2000) then
        PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT * 1.33
    elseif (LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON >= 1500) then
        PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT * 1.12
    elseif (LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON >= 1000) then
        PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT * 1.00
    elseif (LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON >= 700) then
        PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT * 0.85
    elseif (LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON >= 400) then
        PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT * 0.6
    else
        PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT * 0.4
    end
    -- if the slider is set at '0', don't add any new mutants
    if (LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON == 0) then
        PERCENTAGE_TO_SPAWN_MUTANTS = 0
        PERCENTAGE_TO_SPAWN_MWOLF = 0
        RNG_percentage = 0
        ADDON_DISABLED_0_VALUE = true -- if true, conditions for spawning new mutants will not be met
    end
    -- to work with U4H8, which cannot set this value in-game in the settings
    local dyn_mutants_enable_all_additional_mutants = dyn_mutants_enable_all_additional_mutants
    ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS =
        dyn_mutants_enable_all_additional_mutants -- or ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS_DEFAULT
    -- if ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS then news_manager.send_tip(db.actor, " mwolf - enabled " , nil, nil, MESSAGE_DURATION * 1000 ) end
    -- if ( not ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS ) then news_manager.send_tip(db.actor, " mwolf - disabled " , nil, nil, MESSAGE_DURATION * 1000 ) end
end

function check_whether_to_spawn_dynamic_mutants()
    -- check the table/data with stored IDs about existing mutants, count their numbers, etc
    local id_check = 0
    local EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = 0
    local DEAD_MUTANT_IDS_IN_TABLE_COUNTER = 0
    MUTANT_IDS_IN_A_TABLE = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE)
    for iii = 1, 65534 do
        id_check = iii
        if (id_check) and (alife_object(id_check)) and MUTANT_IDS_IN_A_TABLE[id_check] then
            if (string_match(MUTANT_IDS_IN_A_TABLE[id_check], id_check)) then
                EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = EXISTING_MUTANT_IDS_IN_TABLE_COUNTER + 1
            else
                MUTANT_IDS_IN_A_TABLE[iii] = nil
                DEAD_MUTANT_IDS_IN_TABLE_COUNTER = DEAD_MUTANT_IDS_IN_TABLE_COUNTER + 1
            end
        end
    end
    -- ==> now, EXISTING_MUTANT_IDS_IN_TABLE_COUNTER contain the exact number of currently existing DynMutants , (all thr. the Zone)
    set_max_numbers_limit() -- LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON contains the NUMBER_LIMIT that the DynMutant numbers need to be close to.
    -- calculate the difference  ( if positive --> continue adding mutants next day; if negative --> wait for culling of mutants )
    local CURRENT_NUMBERS_to_LIMIT_NUMBER_DIFFERENCE =
        LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON * LIMIT_COEFFICIENT - EXISTING_MUTANT_IDS_IN_TABLE_COUNTER
    if (CURRENT_NUMBERS_to_LIMIT_NUMBER_DIFFERENCE > 0) then
        ENOUGH_MUTANTS_CULLED = true
    else
        ENOUGH_MUTANTS_CULLED = false
    end
    local current_game_time = utils_data.CTimeToSec(game.get_game_time()) / 3600 / 24 -- in-game DAYS from NEW_START
    -- if an EMISSION 'messes up' the 'last_time_to_spawn_dynamic_mutants' time stamp, re-'set' it by ' = current_game_time'
    if (current_game_time < last_time_to_spawn_dynamic_mutants) then
        last_time_to_spawn_dynamic_mutants = current_game_time
    end
    if (last_time_to_spawn_dynamic_mutants == 0) then
        -- i.e. first start of the script, need to set the 'last_time_to_spawn_dynamic_mutants'/'next_time_to_spawn_dynamic_mutants' to appropriate values
        -- time interval for next spawn, (in days), from last_time_to_spawn; 'default' should be 6-8 days
        next_time_to_spawn_dynamic_mutants =
            math_random(
            TIME_INTERVAL_BETWEEN_CONSECUTIVE_SPAWNS - DAYS_THRESHOLD,
            TIME_INTERVAL_BETWEEN_CONSECUTIVE_SPAWNS + DAYS_THRESHOLD
        ) or 7 -- ' or 7' <-- in case there is error with calculations
        -- save the current_time of successful spawn
        last_time_to_spawn_dynamic_mutants = utils_data.CTimeToSec(game.get_game_time()) / 3600 / 24 -- in-game DAYS from NEW_START
        spawn_dynamic_mutants() -- spawn a 'wave' of DYNAMIC_MUTANTS, at first start
    elseif
        ((current_game_time - last_time_to_spawn_dynamic_mutants) > next_time_to_spawn_dynamic_mutants) and
            ENOUGH_MUTANTS_CULLED
     then
        spawn_dynamic_mutants() -- spawn a 'wave' of DYNAMIC_MUTANTS, after 6-8 days, (if the Player has 'over slept', do it after wake up)
    end
    --[[
local time_until_next_attack = next_time_to_spawn_dynamic_mutants - (current_game_time - last_time_to_spawn_dynamic_mutants)
news_manager.send_tip(db.actor, "Next attack in: " .. tonumber(string.format("%.3f", time_until_next_attack)) .. " hours" , nil, nil, 7000 )
news_manager.send_tip(db.actor, "LAST_TIME_SPAWNED in: " .. tonumber(string.format("%.3f", last_time_to_spawn_dynamic_mutants)) .. " hours" , nil, nil, 7000 )
news_manager.send_tip(db.actor, "NEXT_TIME_TO_SPAWN in: " .. tonumber(string.format("%.3f", next_time_to_spawn_dynamic_mutants)) .. " hours" , nil, nil, 7000 )
news_manager.send_tip(db.actor, "CURRENT_GAME_TIME: " .. tonumber(string.format("%.3f", current_game_time)) .. " hours" , nil, nil, 7000 )
news_manager.send_tip(db.actor, "---------------------" , nil, nil, 7000 )
--]]
end

function spawn_dynamic_mutants()
    -- count the numbers of additional BIRDS, GERMAN SHEPHERDS, FOXES, CHICKENS
    -- DO NOT ADD MORE THAN set as max in the appropriate VARs
    -- NOTE: this process takes approx. ~100 ms
    local current_number_of_addit_birds_in_the_zone = count_additional_birds() -- count the existing birds, and do not add more if " > MAX_NUMBER_OF_ADDIT_BIRDS_IN_THE_ZONE "
    local table_numbers = count_currently_existing_german_shepherds_foxes_chickens()
    local current_number_of_german_shepherds_in_the_zone = table_numbers[1]
    local current_number_of_foxes_in_the_zone = table_numbers[2]
    local current_number_of_chickens_in_the_zone = table_numbers[3]
    -- to get the current ID utilization, and check VS a limit (ex: 55.000), on whether to add more mutants, etc...
    -- NOTE: it makes a ~100ms stutter; not very noticeable when a new 'wave' of 1000s+ of mutants are spawned/added thr. the Zone
    IDs_utilized_current_number = 0
    local sim = alife()
    for i = 1, 65534 do
        local se_obj = sim:object(i)
        if (se_obj) then
            IDs_utilized_current_number = IDs_utilized_current_number + 1
        end
    end
    -- news_manager.send_tip(db.actor, "IDs utilized: " .. IDs_utilized_current_number , nil, nil, 7000 )
    set_max_numbers_limit()
    local PERCENTAGE_TO_SPAWN_MUTANTS_factor = PERCENTAGE_TO_SPAWN_MUTANTS -- or PERCENTAGE_TO_SPAWN_MUTANTS_DEFAULT
    NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = 0 -- re-set it, to start counting mutants in this 'wave'
    -- to run several 'waves' at once, (instead of only one)
    for kk = 0, INCREASED_SPAWN_MUTANTS_FACTOR - 1 do -- =====================================================================================
        RNG_percentage = math_random(-5, 5) -- to add variety to the mutant numbers attacking; i.e. 25-35%, instead of the 'flat' 30%
        -- 'ported' German Shepherd - tame dog, ("medwed" community, neutral to all)
        -- best suited to record positions in human settlements, bases, 2-3 per should be enough
        --- they will stay in the area, doing their stuff
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_GERMAN_SHEPHERD.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_GERMAN_SHEPHERD___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_GERMAN_SHEPHERD___[m]
            -- also, check the distance from Player, 30m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local PERCENTAGE_TO_SPAWN_GERMAN_SHEPHERD_modified = PERCENTAGE_TO_SPAWN_GERMAN_SHEPHERD
            -- to add less of these in the less_freq_visited maps, (which get populated now every 'wave', instead of every 4th one)
            if is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) then
                PERCENTAGE_TO_SPAWN_GERMAN_SHEPHERD_modified = PERCENTAGE_TO_SPAWN_GERMAN_SHEPHERD / 4
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            if
                (current_number_of_german_shepherds_in_the_zone < MAX_NUMBER_OF_GERMAN_SHEPHERDS_IN_THE_ZONE) and
                    (ADDON_DISABLED_0_VALUE == false) and
                    ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_GERMAN_SHEPHERD_modified) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                -- for singular mutants
                -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                if (not string_match(chosen_mutant, "simulation")) then
                    printf("spawning dynamic mutant %s", chosen_mutant)
                    local se = sim:create(chosen_mutant, pos, lid, gid)
                    msg(" ----- GERMAN SHEPHERD spawned")
                    -- to store the ID number in a field in the table
                    MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                    TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                    NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                else
                    -- news_manager.send_tip(db.actor, "---- simulation spawn ATTEMPTED: " ..  chosen_mutant , nil, nil, 10000 )
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- 'ported' Chicken - flightless bird, ("rotan" community, neutral to all)
        -- best suited for the German_Shepherd recorded positions in small human settlements, and with a bit higher numbers than Germ_Sheph
        -- remove them from maps with bases, i.e. only in these maps: Jupiter, Yantar, Truck Cemetery, Garbage, Dark Valley, Meadows, Swamps, Cordon,
        --- they will stay in the area, doing their stuff, maybe cooing a bit, making the area feel more "lived in"
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_GERMAN_SHEPHERD.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_CHICKEN___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_CHICKEN___[m]
            -- also, check the distance from Player, 30m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local PERCENTAGE_TO_SPAWN_CHICKEN_modified = PERCENTAGE_TO_SPAWN_CHICKEN
            -- to add less of these in the less_freq_visited maps, (which get populated now every 'wave', instead of every 4th one)
            if is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) then
                PERCENTAGE_TO_SPAWN_CHICKEN_modified = PERCENTAGE_TO_SPAWN_CHICKEN / 4
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            -- check whether it is among the maps that are suitable for CHICKENS
            -- "rural" areas: Jupiter, Yantar, Truck Cemetery, Garbage, Dark Valley, Meadows, Swamps, Cordon
            local IS_IN_SUITABLE_CHICKEN_MAP =
                (map_pos == "Jupiter") or (map_pos == "Yantar") or (map_pos == "theTruckCemetery") or
                (map_pos == "theGarbage") or
                (map_pos == "DarkValley") or
                (map_pos == "theMeadow") or
                (map_pos == "theGreatSwamp") or
                (map_pos == "Cordon")
            if
                (current_number_of_chickens_in_the_zone < MAX_NUMBER_OF_CHICKENS_IN_THE_ZONE) and
                    IS_IN_SUITABLE_CHICKEN_MAP and
                    (ADDON_DISABLED_0_VALUE == false) and
                    ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_CHICKEN_modified) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                -- for singular mutants
                -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                if (not string_match(chosen_mutant, "simulation")) then
                    printf("spawning dynamic mutant %s", chosen_mutant)
                    local se = sim:create(chosen_mutant, pos, lid, gid)
                    msg(" ----- CHICKEN spawned")
                    -- to store the ID number in a field in the table
                    MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                    TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                    NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                else
                    -- news_manager.send_tip(db.actor, "---- simulation spawn ATTEMPTED: " ..  chosen_mutant , nil, nil, 10000 )
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- local ___Dynamic_Mutants_FOX_RED___ = {"fox_red" }
        -- local Dynamic_Mutants_FOX_RED___NUMBER_of_ENTRIES = 1
        -- red FOX, on BOAR/FLESH recorded positions
        -- "ambiental fauna" fox, hostile only to/from tushkanos/rats, "fox" community
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_BOAR_FLESH.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_FOX_RED___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_FOX_RED___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local PERCENTAGE_TO_SPAWN_RED_FOX_modified = PERCENTAGE_TO_SPAWN_RED_FOX
            -- to add less of these in the less_freq_visited maps, (which get populated now every 'wave', instead of every 4th one)
            if is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) then
                PERCENTAGE_TO_SPAWN_RED_FOX_modified = PERCENTAGE_TO_SPAWN_RED_FOX / 4
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            -- for 'optimized', specific PERCENTAGE for each map
            local coeff = get_current_map_optimized_coeff(map_pos)
            -- and (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage) )
            if
                (current_number_of_foxes_in_the_zone < MAX_NUMBER_OF_RED_FOXES_IN_THE_ZONE) and
                    (ADDON_DISABLED_0_VALUE == false) and
                    ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_RED_FOX_modified) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage)) and
                    (IDs_utilized_current_number < 55000) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                -- for singular mutants
                -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                if (not string_match(chosen_mutant, "simulation")) then
                    printf("spawning dynamic mutant %s", chosen_mutant)
                    local se = sim:create(chosen_mutant, pos, lid, gid)
                    msg(" ----- FOX spawned")
                    -- to store the ID number in a field in the table
                    MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                    TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                    NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- 'ported' Piranha, ("komar" community, hostile only to Player/human_NPCs)
        -- best suited to record positions in marshes, shallow lakes, ponds, etc... up to 1-2 per should be enough
        --- they will stay in the area, doing their stuff; will attack if Player/NPCs come close
        ---- 10 aboveground maps suitable, (incl. the small pond in Generators)
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_PIRANHA.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_PIRANHA___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_PIRANHA___[m]
            -- also, check the distance from Player, 30m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local SPAWN_IN_LESS_FREQ_POP_MAP = false
            if IS_IN_LESS_FREQ_POP_MAP then
                if ACCEPTABLE_TIMES_SPAWNED_UG then
                    SPAWN_IN_LESS_FREQ_POP_MAP = true
                end
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            if
                (ADDON_DISABLED_0_VALUE == false) and ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_PIRANHAS) and
                    (IDs_utilized_current_number < 55000) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                -- for singular mutants
                -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                if (not string_match(chosen_mutant, "simulation")) then
                    printf("spawning dynamic mutant %s", chosen_mutant)
                    local se = sim:create(chosen_mutant, pos, lid, gid)
                    -- msg(" ----- PIRANHA spawned")
                    -- to store the ID number in a field in the table
                    MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                    TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                    NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- RODENTS, rats,tushkanos
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_RODENTS.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_RODENTS___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_RODENTS___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local SPAWN_IN_LESS_FREQ_POP_MAP = false
            if IS_IN_LESS_FREQ_POP_MAP then
                if ACCEPTABLE_TIMES_SPAWNED_UG then
                    SPAWN_IN_LESS_FREQ_POP_MAP = true
                end
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            -- for 'optimized', specific PERCENTAGE for each map
            local coeff = get_current_map_optimized_coeff(map_pos)
            if
                (ADDON_DISABLED_0_VALUE == false) and (RNG_pp <= PERCENTAGE_TO_SPAWN_RODENTS) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                if (chosen_mutant == "simulation_rodents") then -- create a 'pattern' of mutants
                    -- randomize the mutants used, from the source_table (without the last ""simulation_" entry)
                    local chosen_mutant_1 =
                        ___Dynamic_Mutants_RODENTS___[math_random(1, Dynamic_Mutants_RODENTS___NUMBER_of_ENTRIES - 2)]
                    local chosen_mutant_2 =
                        ___Dynamic_Mutants_RODENTS___[math_random(1, Dynamic_Mutants_RODENTS___NUMBER_of_ENTRIES - 2)]
                    local chosen_mutant_3 =
                        ___Dynamic_Mutants_RODENTS___[math_random(1, Dynamic_Mutants_RODENTS___NUMBER_of_ENTRIES - 2)]
                    local se1 = sim:create(chosen_mutant_1, pos, lid, gid)
                    local se2 = sim:create(chosen_mutant_2, pos, lid, gid)
                    if (RNG_p > 70) then
                        local se3 = sim:create(chosen_mutant_3, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        MUTANT_IDS_IN_A_TABLE[se3.id] = se3:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 3
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 3
                    else
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 2
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 2
                    end
                else
                    -- for singular mutants
                    -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                    -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                    if (not string_match(chosen_mutant, "simulation")) then
                        printf("spawning dynamic mutant %s", chosen_mutant)
                        local se = sim:create(chosen_mutant, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                    end
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- CROWS/BIRDS, on BOAR/FLESH recorded positions
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_BOAR_FLESH.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_CROWS___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_CROWS___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local PERCENTAGE_TO_SPAWN_BIRDS_modified = PERCENTAGE_TO_SPAWN_BIRDS
            -- to add less of these in the less_freq_visited maps, (which get populated now every 'wave', instead of every 4th one)
            if is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) then
                PERCENTAGE_TO_SPAWN_BIRDS_modified = PERCENTAGE_TO_SPAWN_BIRDS / 4
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            -- for 'optimized', specific PERCENTAGE for each map
            local coeff = get_current_map_optimized_coeff(map_pos)
            -- PERCENTAGE_TO_SPAWN_BIRDS_modified = PERCENTAGE_TO_SPAWN_BIRDS_modified * coeff -- optimized number of Alife and appropriate number of birds
            -- " and (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage) ) " <-- ignore performance_coeff for the birds
            -- and (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage) )
            if
                (current_number_of_addit_birds_in_the_zone < MAX_NUMBER_OF_ADDIT_BIRDS_IN_THE_ZONE) and
                    (ADDON_DISABLED_0_VALUE == false) and
                    ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_BIRDS_modified) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage)) and
                    (IDs_utilized_current_number < 55000) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                -- for singular mutants
                -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                if (not string_match(chosen_mutant, "simulation")) then
                    printf("spawning dynamic mutant %s", chosen_mutant)
                    local se = sim:create(chosen_mutant, pos, lid, gid)
                    -- msg(" ----- BIRD spawned")
                    -- to store the ID number in a field in the table
                    MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                    TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                    NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- BOAR, FLESH
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_BOAR_FLESH.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_BOAR_FLESH___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_BOAR_FLESH___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local SPAWN_IN_LESS_FREQ_POP_MAP = false
            if IS_IN_LESS_FREQ_POP_MAP then
                if ACCEPTABLE_TIMES_SPAWNED_UG then
                    SPAWN_IN_LESS_FREQ_POP_MAP = true
                end
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            -- for 'optimized', specific PERCENTAGE for each map
            local coeff = get_current_map_optimized_coeff(map_pos)
            if
                (ADDON_DISABLED_0_VALUE == false) and (RNG_pp <= PERCENTAGE_TO_SPAWN_BOAR_FLESH) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                if (chosen_mutant == "simulation_boar_flesh") then -- create a 'pattern' of mutants
                    -- randomize the mutants used, from the source_table (without the last ""simulation_" entry)
                    local chosen_mutant_1 =
                        ___Dynamic_Mutants_BOAR_FLESH___[
                        math_random(1, Dynamic_Mutants_BOAR_FLESH___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_2 =
                        ___Dynamic_Mutants_BOAR_FLESH___[
                        math_random(1, Dynamic_Mutants_BOAR_FLESH___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_3 =
                        ___Dynamic_Mutants_BOAR_FLESH___[
                        math_random(1, Dynamic_Mutants_BOAR_FLESH___NUMBER_of_ENTRIES - 2)
                    ]
                    local se1 = sim:create(chosen_mutant_1, pos, lid, gid)
                    local se2 = sim:create(chosen_mutant_2, pos, lid, gid)
                    if (RNG_p > 70) then
                        local se3 = sim:create(chosen_mutant_3, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        MUTANT_IDS_IN_A_TABLE[se3.id] = se3:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 3
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 3
                    else
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 2
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 2
                    end
                else
                    -- for singular mutants
                    -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                    -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                    if (not string_match(chosen_mutant, "simulation")) then
                        printf("spawning dynamic mutant %s", chosen_mutant)
                        local se = sim:create(chosen_mutant, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                    end
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- added the "poltergeist_build" (corporeal version) in this group/rec_pos
        -- ZOMBIES_FRACTURE
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_ZOMBIES_FRACTURE.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_ZOMBIES_FRACTURE___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_ZOMBIES_FRACTURE___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local SPAWN_IN_LESS_FREQ_POP_MAP = false
            if IS_IN_LESS_FREQ_POP_MAP then
                if ACCEPTABLE_TIMES_SPAWNED_UG then
                    SPAWN_IN_LESS_FREQ_POP_MAP = true
                end
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            -- for 'optimized', specific PERCENTAGE for each map
            local coeff = get_current_map_optimized_coeff(map_pos)
            if
                (ADDON_DISABLED_0_VALUE == false) and (RNG_pp <= PERCENTAGE_TO_SPAWN_ZOMBIES_FRACTURE) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                if (chosen_mutant == "simulation_zombies_fracture") then -- create a 'pattern' of mutants
                    -- randomize the mutants used, from the source_table (without the last ""simulation_" entry)
                    local chosen_mutant_1 =
                        ___Dynamic_Mutants_ZOMBIES_FRACTURE___[
                        math_random(1, Dynamic_Mutants_ZOMBIES_FRACTURE___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_2 =
                        ___Dynamic_Mutants_ZOMBIES_FRACTURE___[
                        math_random(1, Dynamic_Mutants_ZOMBIES_FRACTURE___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_3 =
                        ___Dynamic_Mutants_ZOMBIES_FRACTURE___[
                        math_random(1, Dynamic_Mutants_ZOMBIES_FRACTURE___NUMBER_of_ENTRIES - 2)
                    ]
                    local se1 = sim:create(chosen_mutant_1, pos, lid, gid)
                    local se2 = sim:create(chosen_mutant_2, pos, lid, gid)
                    if (RNG_p > 70) then
                        local se3 = sim:create(chosen_mutant_3, pos, lid, gid)
                        if (chosen_mutant_1 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in MAIN")
                        end
                        if (chosen_mutant_2 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in MAIN")
                        end
                        if (chosen_mutant_3 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in MAIN")
                        end
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        MUTANT_IDS_IN_A_TABLE[se3.id] = se3:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 3
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 3
                    else
                        if (chosen_mutant_1 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in MAIN")
                        end
                        if (chosen_mutant_2 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in MAIN")
                        end
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 2
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 2
                    end
                else
                    -- for singular mutants
                    -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                    -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                    if (not string_match(chosen_mutant, "simulation")) then
                        if (chosen_mutant_2 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in MAIN")
                        end
                        printf("spawning dynamic mutant %s", chosen_mutant)
                        local se = sim:create(chosen_mutant, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                    end
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- BLOODSUCKER
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_BLOODSUCKER.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        -- UPDATE, IMPORTANT: you can determine the time_passed_since start, with 'current_time_compare', it will be in hours here
        -- i.e. 'timestamp_when_playthrough_started' is (potentially) not needed
        -- check for the time delay (in days), after that PERCENTAGE to spawn chimera/giant is back to normal, (from 0)
        -- 0-10 days, 0%, 10-15 days, 25%, >15 days, 50%, (this is still much lower than probability for all the other noct_mutants)
        local current_time_days = get_time_elapsed_from_new_game_start()
        local PERCENTAGE_TO_SPAWN_BLOODSUCKER_delayed = 0
        if (current_time_days >= (DELAY_SPAWN_OF_BLOODSUCKER_FOR_THE_FIRST_N_DAYS * 1.5)) then
            PERCENTAGE_TO_SPAWN_BLOODSUCKER_delayed = PERCENTAGE_TO_SPAWN_BLOODSUCKER
        elseif (current_time_days >= (DELAY_SPAWN_OF_BLOODSUCKER_FOR_THE_FIRST_N_DAYS)) then
            PERCENTAGE_TO_SPAWN_BLOODSUCKER_delayed = PERCENTAGE_TO_SPAWN_BLOODSUCKER / 2
        end
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_BLOODSUCKER___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_BLOODSUCKER___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local SPAWN_IN_LESS_FREQ_POP_MAP = false
            if IS_IN_LESS_FREQ_POP_MAP then
                if ACCEPTABLE_TIMES_SPAWNED_UG then
                    SPAWN_IN_LESS_FREQ_POP_MAP = true
                end
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            -- for 'optimized', specific PERCENTAGE for each map
            local coeff = get_current_map_optimized_coeff(map_pos)
            if
                (ADDON_DISABLED_0_VALUE == false) and (RNG_pp <= PERCENTAGE_TO_SPAWN_BLOODSUCKER_delayed) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                if (chosen_mutant == "simulation_bloodsucker") then -- create a 'pattern' of mutants
                    -- randomize the mutants used, from the source_table (without the last ""simulation_" entry)
                    local chosen_mutant_1 =
                        ___Dynamic_Mutants_BLOODSUCKER___[
                        math_random(1, Dynamic_Mutants_BLOODSUCKER___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_2 =
                        ___Dynamic_Mutants_BLOODSUCKER___[
                        math_random(1, Dynamic_Mutants_BLOODSUCKER___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_3 =
                        ___Dynamic_Mutants_BLOODSUCKER___[
                        math_random(1, Dynamic_Mutants_BLOODSUCKER___NUMBER_of_ENTRIES - 2)
                    ]
                    local se1 = sim:create(chosen_mutant_1, pos, lid, gid)
                    local se2 = sim:create(chosen_mutant_2, pos, lid, gid)
                    if (RNG_p > 70) then
                        local se3 = sim:create(chosen_mutant_3, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        MUTANT_IDS_IN_A_TABLE[se3.id] = se3:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 3
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 3
                    else
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 2
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 2
                    end
                else
                    -- for singular mutants
                    -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                    -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                    if (not string_match(chosen_mutant, "simulation")) then
                        printf("spawning dynamic mutant %s", chosen_mutant)
                        local se = sim:create(chosen_mutant, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                    end
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- added the MWolf ("mwolf") in this group
        -- CHIMERA_GIANT
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_CHIMERA_GIANT.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS")
        -- UPDATE, IMPORTANT: you can determine the time_passed_since start, with 'current_time_compare', it will be in hours here
        -- i.e. 'timestamp_when_playthrough_started' is (potentially) not needed
        -- check for the time delay (in days), after that PERCENTAGE to spawn chimera/giant is back to normal, (from 0)
        -- 0-10 days, 0%, 10-15 days, 20%, >15 days, 40%, (this is still much lower than probability for all the other noct_mutants)
        local current_time_days = get_time_elapsed_from_new_game_start()
        local PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed = 0
        if (current_time_days >= (DELAY_SPAWN_OF_CHIMERA_GIANT_FOR_THE_FIRST_N_DAYS * 1.5)) then
            PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed = PERCENTAGE_TO_SPAWN_CHIMERA_GIANT
        elseif (current_time_days >= (DELAY_SPAWN_OF_CHIMERA_GIANT_FOR_THE_FIRST_N_DAYS)) then
            PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed = PERCENTAGE_TO_SPAWN_CHIMERA_GIANT / 2
        end
        -- news_manager.send_tip(db.actor, "current_time_days: " .. current_time_days , nil, nil, 7000 )
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_CHIMERA_GIANT___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_CHIMERA_GIANT___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- a check whether the CURRENT_POSITION is in a less-frequently_visited map, and if so, whether it is the required 'rarer' 'wave'
            local IS_IN_LESS_FREQ_POP_MAP = is_it_LESS_FREQ_POP_map_ENG_NAME(map_pos) -- these maps need less frequent 'waves'
            -- check whether TIMES_SPAWNED is an INTEGER_NUMBER* POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local temp = math_floor(TIMES_SPAWNED / POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED)
            temp = temp * POPULATE_LESS_FREQ_POP_MAPS_AFTER_N_TIMES_SPAWNED
            local ACCEPTABLE_TIMES_SPAWNED_UG = (TIMES_SPAWNED == 0) or (temp == TIMES_SPAWNED)
            local SPAWN_IN_LESS_FREQ_POP_MAP = false
            if IS_IN_LESS_FREQ_POP_MAP then
                if ACCEPTABLE_TIMES_SPAWNED_UG then
                    SPAWN_IN_LESS_FREQ_POP_MAP = true
                end
            end
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            -- PERCENTAGE_TO_SPAWN a CHIMERA_GIANT
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            -- for 'optimized', specific PERCENTAGE for each map
            local coeff = get_current_map_optimized_coeff(map_pos)
            -- news_manager.send_tip(db.actor, "current_time_compare: " .. current_time_compare , nil, nil, 7000 )
            -- news_manager.send_tip(db.actor, "PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed: " .. PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed , nil, nil, 7000 )
            -- news_manager.send_tip(db.actor, "-----------------------------" , nil, nil, 7000 )
            -------------------------- treating the VOLK, MEDVED, TARK separately from Ch/G settings,percentages start
            -- to create a random 'pack', MAYbe having one leader, even MAYbe two, with two 'normal' ones, or one leader, or no leaders...
            -- in short, can have: 1-4 volks, 0-2 leaders
            -- IMPORTANT NOTE: chimera and pseudodog 'communities' are neutral to each other, so, you can 'mix' from these
            -- NOTE/CAUTION: "medved_smaller", (90% resized), is (currently) lower-poly mesh, which is very noticeable
            -- "medved_dark" will show up after 10 days, with the Chimera/Giant and VOLK_Top_Dog
            local ___VOLK_MEDVED_TARK___ = {
                "mwolf",
                "mwolf",
                "mwolf_leader",
                "medved",
                "medved",
                "tark_smaller",
                "tark_smaller",
                "tark_default",
                "boar_big_monster",
                "boar_big_monster_v2"
            }
            local VOLK_MEDVED_TARK___NUMBER_of_ENTRIES = 10 -- 1 --
            local VOLK_MEDVED_TARK_1 = ___VOLK_MEDVED_TARK___[math_random(1, VOLK_MEDVED_TARK___NUMBER_of_ENTRIES)]
            local VOLK_MEDVED_TARK_2 = ___VOLK_MEDVED_TARK___[math_random(1, VOLK_MEDVED_TARK___NUMBER_of_ENTRIES)]
            local VOLK_MEDVED_TARK_3 = ___VOLK_MEDVED_TARK___[math_random(1, VOLK_MEDVED_TARK___NUMBER_of_ENTRIES)]
            local VOLK_MEDVED_TARK_4 = ___VOLK_MEDVED_TARK___[math_random(1, VOLK_MEDVED_TARK___NUMBER_of_ENTRIES)]
            -- PERCENTAGE_TO_SPAWN a MWOLF
            local RNG_ppp = math_random(1, 100)
            -- local mwolf_name = "mwolf"
            ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS =
                ui_mcm.get("dynamic_mutants/dyn_mutants_enable_all_additional_mutants") -- or ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS_DEFAULT
            -- spawn a MWOLF INDEPENDENT from the CH/G, at any time, with its own PERCENTAGE, (even WITH a Ch/G, at the same time)
            if
                (ADDON_DISABLED_0_VALUE == false) and ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS and
                    (RNG_ppp <= (PERCENTAGE_TO_SPAWN_MWOLF * coeff)) and
                    (IDs_utilized_current_number < 55000) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                -- i.e. if it is selected in the in-game settings
                -- msg ( " ----- TARK, MEDVED, VOLK spawned" )
                local se21 = sim:create(VOLK_MEDVED_TARK_1, pos, lid, gid)
                -- to store the ID number in a field in the table
                MUTANT_IDS_IN_A_TABLE[se21.id] = se21:name()
                if (RNG_p > 80) then
                    local se22 = sim:create(VOLK_MEDVED_TARK_2, pos, lid, gid)
                    -- to store the ID number in a field in the table
                    MUTANT_IDS_IN_A_TABLE[se22.id] = se22:name()
                end
                -- default Volk
                if (RNG_p > 90) then
                    local se23 = sim:create(VOLK_MEDVED_TARK_3, pos, lid, gid)
                    -- to store the ID number in a field in the table
                    MUTANT_IDS_IN_A_TABLE[se23.id] = se23:name()
                end
                -- default Volk
                if (RNG_p > 98) then
                    local se24 = sim:create(VOLK_MEDVED_TARK_4, pos, lid, gid)
                    -- to store the ID number in a field in the table
                    MUTANT_IDS_IN_A_TABLE[se24.id] = se24:name()
                end
            end
            -------------------------- treating the VOLK, MEDVED, TARK separately from Ch/G settings,percentages end
            -- news_manager.send_tip(db.actor, current_time_compare , nil, nil, 7000 )
            -- news_manager.send_tip(db.actor, timestamp_when_playthrough_started , nil, nil, 7000 )
            -- news_manager.send_tip(db.actor, 24 * DELAY_SPAWN_OF_CHIMERA_GIANT_FOR_THE_FIRST_N_DAYS , nil, nil, 7000 )
            -- news_manager.send_tip(db.actor, "-----------------------------" , nil, nil, 7000 )
            if
                (ADDON_DISABLED_0_VALUE == false) and (RNG_pp <= PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_MUTANTS_factor * coeff + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                -- if the 'addit._mutants' setting is disabled in settings, they shouldn't appear even after 12th day mark
                ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS =
                    ui_mcm.get("dynamic_mutants/dyn_mutants_enable_all_additional_mutants") -- or ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS_DEFAULT
                if (chosen_mutant == "vendigo") then
                    msg(" ----- VENDIGO spawned ")
                end
                -- to exclude the 'tougher' additional mutants from showing up within the first 10 days
                if (ENABLE_THE_INCLUSION_OF_ALL_ADDITIONAL_MUTANTS == false) then
                    if
                        (string_match(chosen_mutant, "mwolf")) or (string_match(chosen_mutant, "medved")) or
                            (string_match(chosen_mutant, "boar_big_monster")) or
                            (string_match(chosen_mutant, "vendigo"))
                     then
                        if (RNG_p > 60) then
                            chosen_mutant = "chimera_normal"
                        else
                            chosen_mutant = "chimera_weak"
                        end
                    end
                end
                -- if the addit._mutants setting is disabled in settings, they shouldn't appear even after 12th day mark
                if (chosen_mutant == "simulation_chimera_giant") then -- create a 'pattern' of mutants
                    -- choose randomly ONE CHIMERA, ONE LURKER and possibly another lurker
                    local chosen_mutant_1 =
                        ___Dynamic_Mutants_CHIMERA_GIANT___[
                        math_random(1, Dynamic_Mutants_CHIMERA_GIANT___CHIMERA_NUMBER_of_ENTRIES)
                    ]
                    local se1 = sim:create(chosen_mutant_1, pos, lid, gid)
                    local se2 = sim:create("lurker_1_strong", pos, lid, gid)
                    if (RNG_p > 70) then
                        local se3 = sim:create("lurker_2_strong", pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        MUTANT_IDS_IN_A_TABLE[se3.id] = se3:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 3
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 3
                    else
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE[se2.id] = se2:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 2
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 2
                    end
                else
                    -- for singular mutants, i.e. not a Chimera+Lurker(s) -- example: chimera, giant, medved_dark, volk_topdog
                    -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                    -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                    if (chosen_mutant == "boar_big_monster") then
                        msg(" ----- MONSTER BOAR spawned")
                    end
                    if (chosen_mutant == "boar_big_monster_v2") then
                        msg(" ----- MONSTER BOAR _v2 spawned")
                    end
                    if (chosen_mutant == "vendigo") then
                        msg(" ----- VENDIGO spawned")
                    end
                    if (not string_match(chosen_mutant, "simulation")) then
                        printf("spawning dynamic mutant %s", chosen_mutant)
                        local se = sim:create(chosen_mutant, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE[se.id] = se:name()
                        TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED + 1
                        NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE + 1
                    end
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
    end -- =====================================================================================
    -- to run several 'waves' at once, (instead of only one)
    -- calculate next time/night/hour to spawn the DYNAMIC_MUTANTS
    -- time interval for next spawn, (in days), from last_time_to_spawn; 'default' should be 6-8 days
    next_time_to_spawn_dynamic_mutants =
        math_random(
        TIME_INTERVAL_BETWEEN_CONSECUTIVE_SPAWNS - DAYS_THRESHOLD,
        TIME_INTERVAL_BETWEEN_CONSECUTIVE_SPAWNS + DAYS_THRESHOLD
    ) or 2 -- ' or 2' <-- in case there is error with calculations
    -- save the current_time of successful spawn
    last_time_to_spawn_dynamic_mutants = utils_data.CTimeToSec(game.get_game_time()) / 3600 / 24 -- in-game DAYS from NEW_START
    -- count the successful 'waves'/spawns of dynamic_mutants
    TIMES_SPAWNED = TIMES_SPAWNED + 1
    -- decrease the PERCENTAGE in steps, until it comes close to the LOWEST_PERCENTAGE
    -- if ( (PERCENTAGE_TO_SPAWN_MUTANTS - PERCENTAGE_STEP_DECREASE) >= LOWEST_PERCENTAGE_TO_SPAWN_MUTANTS ) then PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS - PERCENTAGE_STEP_DECREASE end
    -- to remove any unselected additional mutants
    remove_unselected_additional_mutants()
end
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------ functions added for populating the UG maps and the SPECIFIC_LOCATIONS ------------
--------- ===================================================================================== ---------
-- IDs are kept in the MUTANT_IDS_IN_A_TABLE_UG table

function check_whether_to_despawn_UG_MAPS_population()
    if (UG_maps_are_populated) then
        -- msg ( " --- UG_maps_ ARE populated" )
    else
        -- msg ( " --- UG_maps_ are NOT populated" )
    end
    if (not UG_maps_are_populated) then
        return -- at the beginning, when the UG maps haven't even been visited, exit the function here
    end
    if
        ((get_time_elapsed_from_new_game_start() - UG_maps_got_populated_at_day) <
            depopulate_UG_maps_after_N_days_of_no_visit)
     then
        return -- exit this function, if a few days haven't yet passed after the last visit to an UG map
    end
    if (is_it_UG_map(level.name())) then
        return -- do a quick check on whether the current map is NOT one of the 7 UG maps
    -- need to de-populate the UG maps ONLY when Player is in an aboveground map, (and after a few days of no visit)
    end
    -- if passed through here, the Player IS in a non_UG map AND a few days have passed after the last visit to an UG map
    -- thus, de-populate the UG alife, (their IDs are 'kept' in an UG_alife_table)
    -- NOTE: exclude any Stalkers that MAY have been taken as "Companions" by the Player
    -- clearing out the table from fields/mutant_names that are not included in the UG spawn
    MUTANT_IDS_IN_A_TABLE_UG = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE_UG)
    -- afterwards, check again before despawning them, just in case
    UG_maps_are_populated = false -- re-set this, so that it may populate the UG maps oon the next visit
    ----------------------------------- start of de-spawning UG maps alife -----------------------
    local id_check = 0
    local EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = 0
    local DESPAWNED_MUTANTS_NUMBER = 0
    local sim = alife()
    MUTANT_IDS_IN_A_TABLE_UG = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE_UG)
    for iii = 1, 65534 do
        id_check = iii
        if (id_check) and (alife_object(id_check)) and MUTANT_IDS_IN_A_TABLE_UG[id_check] then
            if (string_match(MUTANT_IDS_IN_A_TABLE_UG[id_check], id_check)) then
                msg(" ----- DESPAWNED UG Mutant: " .. MUTANT_IDS_IN_A_TABLE_UG[id_check] .. " " .. id_check)
                sim:release(sim:object(id_check)) -- to remove mutants on multiple maps
                DESPAWNED_MUTANTS_NUMBER = DESPAWNED_MUTANTS_NUMBER + 1
            else
                msg(" ------- CLEARED UG field: " .. MUTANT_IDS_IN_A_TABLE_UG[id_check] .. " " .. id_check)
                MUTANT_IDS_IN_A_TABLE_UG[id_check] = nil
            end
        end
    end
    -- UG alife is now not present in the table, anything that (eventually) remains, is something else
    --- so, re-set the table and the counter, to start filling it with new entries
    MUTANT_IDS_IN_A_TABLE_UG = {}
    msg(" ----------- DESPAWNED_UG_ALIFE_NUMBER: " .. DESPAWNED_MUTANTS_NUMBER)
end
--------- ===================================================================================== ---------
-- IDs are kept in the MUTANT_IDS_IN_A_TABLE_SPEC_LOC table

function check_whether_to_despawn_SPEC_LOC_population()
    -- IMPORTANT: if they haven't been killed, leave some of the large mutants at the SPEC_LOC alive, i.e. do not despawn them after 2 days
    -- i.e. leave them free to roam around in the nearby area
    local mutants_to_not_despawn_from_SPEC_LOC = {"mwolf_", "medved", "tark_", "boar_big_monster", "vendigo", "gigant_"}
    local perc_to_keep_a_rare_mutant = dyn_mutants_target_numbers / 20 -- or LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON_DEFAULT
    -- > at 1000 value, set to 50% that an existing rare large mutant gets "set free" (instead of despawned) when the SPEC_LOC are depopulated
    if (perc_to_keep_a_rare_mutant > 70) then
        perc_to_keep_a_rare_mutant = 70
    end
    if
        (SPECIFIC_LOCATIONS_populated.zaton_iron_forest ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.zaton_bs_lair ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.zaton_controller_cave ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.jupiter_volkhov_complex ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.jupiter_abandoned_factory ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.dead_city_abandoned_school ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.army_warehouses_bs_village ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.truck_cemetery_forest ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.meadows_building_factory ~= "populated") and
            (SPECIFIC_LOCATIONS_populated.radar_ne_base ~= "populated")
     then
        return -- if none of the SPEC_LOCATIONS haven't yet been visited, exit this function
    -- this is important, until the very first visit to some of the SPEC_LOC
    end -- AND in the period after they get depopulated and re-set their 'flags' UNTIL another visit
    if
        ((get_time_elapsed_from_new_game_start() - SPEC_LOC_got_populated_at_day) <
            depopulate_SPEC_LOC_after_N_days_of_no_visit)
     then
        return -- exit this function, if a few days haven't yet passed after the last visit to a specific location
    end
    -- if (is_it_SPEC_LOC_map (level.name()) ) then
    -- return -- do a quick check on whether the current map is something other than the maps with specific locations
    -- need to de-populate the SPEC_LOC maps ONLY when Player is in another map, (and after a few days of no visit)
    -- end
    -- UPDATE: it is not reallY necessary to travel to a non-SPEC_LOC map, in order to depopulate these locations
    -- so, this check is not needed
    -- what is needed for despawn function to run:
    -- - at least one of the locations to be populated
    -- - two days to pass
    -- if passed to here, the Player IS in a non_SPEC_LOC map AND a few days have passed after the last visit to a SPEC_LOC map
    -- thus, de-populate the SPEC_LOC alife, (their IDs are 'kept' in an SPEC_LOC_alife_table)
    -- NOTE: exclude any Stalkers that MAY have been taken as "Companions" by the Player
    ----------------------------------- start of de-spawning SPEC_LOC alife -----------------------
    local id_check = 0
    local EXISTING_MUTANT_IDS_IN_TABLE_COUNTER = 0
    local FOUND_MATCH_IN_TABLE = false
    local ___FILTERED_OBJECTS_MUTANT_NAMES___ = ___MUTANT_IDS_IN_A_TABLE_SPEC_LOC__INCLUDED_MUTANT_NAMES___
    local DESPAWNED_MUTANTS_NUMBER = 0
    -- first, 'clear' any non-included mutant names from this table, (crows, dogs, etc...)
    -- an ID number, saved in a field here, might have been empty, (by the original mutant dying off), and then assigned to a vanilla mutant or else
    -- so, go through the tables fields, and "= nil" to every field that doesn't contain a mutant_name fron the 'filtered' table
    MUTANT_IDS_IN_A_TABLE_SPEC_LOC =
        clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE_SPEC_LOC)
    local sim = alife()
    for iii = 1, 65534 do
        id_check = iii
        if (id_check) and (alife_object(id_check)) and MUTANT_IDS_IN_A_TABLE_SPEC_LOC[id_check] then
            if (string_match(MUTANT_IDS_IN_A_TABLE_SPEC_LOC[id_check], id_check)) then
                ------------------- check whether this mutant is one of those to "leave free" instead of despawn at the SPEC_LOC
                local mutant_freed = false
                local FOUND_MATCH_IN_TABLE = false -- start doing a 'match' vs the table_data, when a match is found, 'FOUND_MATCH_IN_TABLE' will be true
                -- iterate all mutant names ( VS the current object_ID_name )
                for n = 1, #mutants_to_not_despawn_from_SPEC_LOC do
                    -- i.e. if didn't had a match yet
                    if alife_object(id_check) and (FOUND_MATCH_IN_TABLE == false) then -- some IDs (1-65534) do not contain an object
                        -- if it found a match, i.e. this ID holds an included Alife, then
                        if (string_match(alife_object(id_check):name(), mutants_to_not_despawn_from_SPEC_LOC[n])) then
                            FOUND_MATCH_IN_TABLE = true -- found a match, exit the current 'for to, table' cycle
                            -- a chance to free it or not
                            if (math_random(0, 100) < perc_to_keep_a_rare_mutant) then
                                mutant_freed = true
                                msg(
                                    " ------- Mutant Freed SPEC_LOC field: " ..
                                        MUTANT_IDS_IN_A_TABLE_SPEC_LOC[id_check] .. " " .. id_check
                                )
                                MUTANT_IDS_IN_A_TABLE_SPEC_LOC[id_check] = nil -- remove entry from table and release free the mutant
                            else
                                mutant_freed = false
                            end
                        end
                    end
                end
                ------------------- check whether this mutant is one ot hose to "leave free" instead of despawn at the SPEC_LOC
                if (not mutant_freed) then
                    msg(
                        " ----- DESPAWNED SPEC_LOC Mutant: " ..
                            MUTANT_IDS_IN_A_TABLE_SPEC_LOC[id_check] .. " " .. id_check
                    )
                    sim:release(sim:object(id_check)) -- to remove mutants on multiple maps
                    DESPAWNED_MUTANTS_NUMBER = DESPAWNED_MUTANTS_NUMBER + 1
                end
            else
                msg(" ------- CLEARED SPEC_LOC field: " .. MUTANT_IDS_IN_A_TABLE_SPEC_LOC[id_check] .. " " .. id_check)
                MUTANT_IDS_IN_A_TABLE_SPEC_LOC[id_check] = nil
            end
        end
    end
    -- re-set the SPEC_LOCATIONS "populated" 'flags'
    SPECIFIC_LOCATIONS_populated = {
        zaton_iron_forest = "",
        zaton_bs_lair = "",
        zaton_controller_cave = "",
        jupiter_volkhov_complex = "",
        jupiter_abandoned_factory = "",
        dead_city_abandoned_school = "",
        army_warehouses_bs_village = "",
        truck_cemetery_forest = "",
        meadows_building_factory = "",
        radar_ne_base = ""
    }
    -- spec_loc alife is now not present in the table, anything that (eventually) remains, is something else
    --- so, re-set the table and the counter, to start filling it with new entries
    MUTANT_IDS_IN_A_TABLE_SPEC_LOC = {}
    msg(" ----------- DESPAWNED_SPEC_LOC_ALIFE_NUMBER: " .. DESPAWNED_MUTANTS_NUMBER)
    ----------------------------------- end of de-spawning SPEC_LOC alife -----------------------
end
--------- ===================================================================================== ---------
-- separate mutant_tables for UG maps, 'simulations'/groups with lowered numbers than in aboveground
local ___Dynamic_Mutants_RODENTS__UG___ = {
    "rat_normal",
    "rat_strong",
    "rat_weak",
    "rat_strong",
    "rat_strong",
    "rat_strong",
    "tushkano_weak",
    "tushkano_strong_b",
    "simulation_rodents",
    "simulation_rodents"
}
local Dynamic_Mutants_RODENTS__UG___NUMBER_of_ENTRIES = 10 -- 1 --
-- re-included the (transparent) "zombie_ghost"; it is suited for appearing in UG maps
local ___Dynamic_Mutants_ZOMBIES_FRACTURE__UG___ = {
    "poltergeist_build",
    "poltergeist_build",
    "zombie_normal",
    "zombie_strong",
    "zombie_weak",
    "zombie_ghol",
    "zombie_teta",
    "zombi_x3",
    "zombi_x4",
    "zombie_ghost",
    "zombie_ghost",
    "zombie_blind",
    "zombie_fake",
    "zombie_teta",
    "zombie_wich",
    "zombi_babka_1",
    "zombi_babka_2",
    "zombi_babka_3",
    "zombi_9",
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "fracture_weak",
    "simulation_zombies_fracture",
    "simulation_zombies_fracture"
}
local Dynamic_Mutants_ZOMBIES_FRACTURE__UG___NUMBER_of_ENTRIES = 25 -- 1 --
local ___Dynamic_Mutants_BLOODSUCKER__UG___ = {
    "bloodsucker_normal",
    "bloodsucker_strong",
    "bloodsucker_weak",
    "bloodsucker_black_strong",
    "bloodsucker_green_normal",
    "bloodsucker_red_weak",
    "lurker_1_strong",
    "lurker_2_strong",
    "lurker_3_strong",
    "lurker_1_normal",
    "lurker_2_normal",
    "simulation_bloodsucker",
    "simulation_bloodsucker"
}
local Dynamic_Mutants_BLOODSUCKER__UG___NUMBER_of_ENTRIES = 13 -- 1 --
local ___Dynamic_Mutants_CHIMERA_GIANT__UG___ = {
    "chimera_normal",
    "chimera_strong",
    "chimera_weak",
    "chimera_normal",
    "chimera_strong4",
    "chimera_weak",
    "gigant_normal",
    "gigant_strong",
    "gigant_weak",
    "gigant_jumper",
    "gigant_jumper"
}
local Dynamic_Mutants_CHIMERA_GIANT__UG___NUMBER_of_ENTRIES = 10 -- 1 --
local Dynamic_Mutants_CHIMERA_GIANT__UG___CHIMERA_NUMBER_of_ENTRIES = 6
-- populate (all 7) UG maps on visit; depopulate after 3 days, if no visit to any of them
-- omit populating with: birds, herbivores, piranhas, additional mutants (medved, tark), german shepherd, fox, chicken
-- population (suitable): rodents, zombies/fractures, bloodsuckers/lurkers, chimera/giant (in the large hall Jupiter_UG)

function spawn_dynamic_mutants_in_UG_maps()
    if (UG_maps_are_populated == true) then
        return -- do a quick check on whether UG maps are already populated, exit this function if they are
    end
    if (not is_it_UG_map(level.name())) then
        return -- do a quick check on whether the current map is one of the 7 UG maps, exit this function if not
    end
    -- keep the day at which the UG maps were populated; de-populate after N days of no visit to any of them
    UG_maps_got_populated_at_day = get_time_elapsed_from_new_game_start()
    UG_maps_are_populated = true
    -- to get the current ID utilization, and check VS a limit (ex: 55.000), on whether to add more mutants, etc...
    -- NOTE: it makes a ~100ms stutter; not very noticeable when a new 'wave' of 1000s+ of mutants are spawned/added thr. the Zone
    IDs_utilized_current_number = 0
    local sim = alife()
    for i = 1, 65534 do
        local se_obj = sim:object(i)
        if (se_obj) then
            IDs_utilized_current_number = IDs_utilized_current_number + 1
        end
    end
    -- news_manager.send_tip(db.actor, "IDs utilized: " .. IDs_utilized_current_number , nil, nil, 7000 )
    -- tipycally = 0.1
    local PERCENTAGE_TO_SPAWN_UG_MUTANTS =
        dyn_mutants_target_numbers * PERCENTAGE_TO_SPAWN_UG_MUTANTS_factor
    -- add an additional variety in the percentage numbers 70-120 %
    PERCENTAGE_TO_SPAWN_UG_MUTANTS = PERCENTAGE_TO_SPAWN_UG_MUTANTS * math_random(65, 110) / 100
    -- to run several 'waves' at once, (instead of only one)
    for kk = 0, INCREASED_SPAWN_MUTANTS_FACTOR - 1 do -- =====================================================================================
        RNG_percentage = math_random(-12, 12) -- to add variety to the mutant numbers attacking; i.e. 88-112%, instead of the 'flat' 100%
        -- RODENTS, rats,tushkanos
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_RODENTS.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS_UG_MAPS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS_UG_MAPS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_RODENTS__UG___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_RODENTS__UG___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            if
                (is_it_UG_map_ENG_NAME(map_pos)) and (ADDON_DISABLED_0_VALUE == false) and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_RODENTS) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_UG_MUTANTS + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                if (chosen_mutant == "simulation_rodents") then -- create a 'pattern' of mutants
                    -- randomize the mutants used, from the source_table (without the last ""simulation_" entry)
                    local chosen_mutant_1 =
                        ___Dynamic_Mutants_RODENTS__UG___[
                        math_random(1, Dynamic_Mutants_RODENTS__UG___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_2 =
                        ___Dynamic_Mutants_RODENTS__UG___[
                        math_random(1, Dynamic_Mutants_RODENTS__UG___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_3 =
                        ___Dynamic_Mutants_RODENTS__UG___[
                        math_random(1, Dynamic_Mutants_RODENTS__UG___NUMBER_of_ENTRIES - 2)
                    ]
                    local se1 = sim:create(chosen_mutant_1, pos, lid, gid)
                    local se2 = sim:create(chosen_mutant_2, pos, lid, gid)
                    if (RNG_p > 70) then
                        local se3 = sim:create(chosen_mutant_3, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE_UG[se2.id] = se2:name()
                        MUTANT_IDS_IN_A_TABLE_UG[se3.id] = se3:name()
                    else
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE_UG[se2.id] = se2:name()
                    end
                else
                    -- for singular mutants
                    -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                    -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                    if (not string_match(chosen_mutant, "simulation")) then
                        printf("spawning dynamic mutant %s", chosen_mutant)
                        local se = sim:create(chosen_mutant, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se.id] = se:name()
                    end
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- added the "poltergeist_build" (corporeal version) in this group/rec_pos
        -- ZOMBIES_FRACTURE
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_ZOMBIES_FRACTURE.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS_UG_MAPS")
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS_UG_MAPS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_ZOMBIES_FRACTURE__UG___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_ZOMBIES_FRACTURE__UG___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            if
                (is_it_UG_map_ENG_NAME(map_pos)) and (ADDON_DISABLED_0_VALUE == false) and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_ZOMBIES_FRACTURE) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_UG_MUTANTS + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                if (chosen_mutant == "simulation_zombies_fracture") then -- create a 'pattern' of mutants
                    -- randomize the mutants used, from the source_table (without the last ""simulation_" entry)
                    local chosen_mutant_1 =
                        ___Dynamic_Mutants_ZOMBIES_FRACTURE__UG___[
                        math_random(1, Dynamic_Mutants_ZOMBIES_FRACTURE__UG___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_2 =
                        ___Dynamic_Mutants_ZOMBIES_FRACTURE__UG___[
                        math_random(1, Dynamic_Mutants_ZOMBIES_FRACTURE__UG___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_3 =
                        ___Dynamic_Mutants_ZOMBIES_FRACTURE__UG___[
                        math_random(1, Dynamic_Mutants_ZOMBIES_FRACTURE__UG___NUMBER_of_ENTRIES - 2)
                    ]
                    local se1 = sim:create(chosen_mutant_1, pos, lid, gid)
                    local se2 = sim:create(chosen_mutant_2, pos, lid, gid)
                    if (RNG_p > 75) then
                        local se3 = sim:create(chosen_mutant_3, pos, lid, gid)
                        if (chosen_mutant_1 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in UG")
                        end
                        if (chosen_mutant_2 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in UG")
                        end
                        if (chosen_mutant_3 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in UG")
                        end
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE_UG[se2.id] = se2:name()
                        MUTANT_IDS_IN_A_TABLE_UG[se3.id] = se3:name()
                    else
                        if (chosen_mutant_1 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in UG")
                        end
                        if (chosen_mutant_2 == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in UG")
                        end
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE_UG[se2.id] = se2:name()
                    end
                else
                    -- for singular mutants
                    -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                    -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                    if (not string_match(chosen_mutant, "simulation")) then
                        if (chosen_mutant == "poltergeist_build") then
                            msg(" ----- POLTERGEIST_CORP spawned in UG")
                        end
                        printf("spawning dynamic mutant %s", chosen_mutant)
                        local se = sim:create(chosen_mutant, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se.id] = se:name()
                    end
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- BLOODSUCKER
        local PERCENTAGE_TO_SPAWN_BLOODSUCKER_UG = 70 -- separate PERCENTAGE for the BS in UG maps
        local DELAY_SPAWN_OF_BLOODSUCKER_FOR_THE_FIRST_N_DAYS_UG = 0 -- keep this, if a delay is ever needed to be impemented
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_BLOODSUCKER.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS_UG_MAPS")
        local current_time_days = get_time_elapsed_from_new_game_start()
        local PERCENTAGE_TO_SPAWN_BLOODSUCKER_delayed = 0
        if (current_time_days >= (DELAY_SPAWN_OF_BLOODSUCKER_FOR_THE_FIRST_N_DAYS_UG * 1.5)) then
            PERCENTAGE_TO_SPAWN_BLOODSUCKER_delayed = PERCENTAGE_TO_SPAWN_BLOODSUCKER_UG
        elseif (current_time_days >= (DELAY_SPAWN_OF_BLOODSUCKER_FOR_THE_FIRST_N_DAYS_UG)) then
            PERCENTAGE_TO_SPAWN_BLOODSUCKER_delayed = PERCENTAGE_TO_SPAWN_BLOODSUCKER_UG / 2
        end
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS_UG_MAPS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_BLOODSUCKER__UG___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_BLOODSUCKER__UG___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            if
                (is_it_UG_map_ENG_NAME(map_pos)) and (ADDON_DISABLED_0_VALUE == false) and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_BLOODSUCKER_delayed) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_UG_MUTANTS + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                if (chosen_mutant == "simulation_bloodsucker") then -- create a 'pattern' of mutants
                    -- randomize the mutants used, from the source_table (without the last ""simulation_" entry)
                    local chosen_mutant_1 =
                        ___Dynamic_Mutants_BLOODSUCKER__UG___[
                        math_random(1, Dynamic_Mutants_BLOODSUCKER__UG___NUMBER_of_ENTRIES - 2)
                    ]
                    local chosen_mutant_2 =
                        ___Dynamic_Mutants_BLOODSUCKER__UG___[
                        math_random(1, Dynamic_Mutants_BLOODSUCKER__UG___NUMBER_of_ENTRIES - 2)
                    ]
                    local se1 = sim:create(chosen_mutant_1, pos, lid, gid)
                    if (RNG_p > 75) then
                        local se2 = sim:create(chosen_mutant_2, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se1.id] = se1:name()
                        MUTANT_IDS_IN_A_TABLE_UG[se2.id] = se2:name()
                    else
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se1.id] = se1:name()
                    end
                else
                    -- for singular mutants
                    -- check whether the "chosen_mutant" is actually a "simulation_" and exclude it.
                    -- (otherwise, It won't spawn anything, but it will give a warning in the console)
                    if (not string_match(chosen_mutant, "simulation")) then
                        printf("spawning dynamic mutant %s", chosen_mutant)
                        local se = sim:create(chosen_mutant, pos, lid, gid)
                        -- to store the ID number in a field in the table
                        MUTANT_IDS_IN_A_TABLE_UG[se.id] = se:name()
                    end
                end
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- CHIMERA_GIANT
        local PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_UG = PERCENTAGE_TO_SPAWN_CHIMERA_GIANT * 2 -- i.e. increase the probability, compared to aboveground
        local ini = ini_file("plugins\\____gather_position_data_MUTANTS_CHIMERA_GIANT.ltx")
        local n = ini:line_count("DYNAMIC_MUTANTS_UG_MAPS")
        local current_time_days = get_time_elapsed_from_new_game_start()
        local PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed = 0
        if (current_time_days >= (DELAY_SPAWN_OF_CHIMERA_GIANT_FOR_THE_FIRST_N_DAYS * 1.5)) then
            PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed = PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_UG
        elseif (current_time_days >= (DELAY_SPAWN_OF_CHIMERA_GIANT_FOR_THE_FIRST_N_DAYS)) then
            PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed = PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_UG / 2
        end
        for k = 0, n - 1 do
            local result, i, v = ini:r_line_ex("DYNAMIC_MUTANTS_UG_MAPS", k)
            local tp = v and str_explode(v, ",")
            local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
            local lid = tonumber(tp[4])
            local gid = tonumber(tp[5])
            -- 'extract' map name of current recorded_position
            local map_pos = string_sub(tp[8], 12) -- " LOCATION: in Dead City, north of the sawmill" ---> map_pos = "DeadCity"
            -- now, to randomly choose a mutant from the available ones in this mutant_group
            local m = math_random(1, Dynamic_Mutants_CHIMERA_GIANT__UG___NUMBER_of_ENTRIES)
            local chosen_mutant = ___Dynamic_Mutants_CHIMERA_GIANT__UG___[m]
            -- also, check the distance from Player, 50m in X-Z, 2m in Y (only when Player is underneath, tunnel, house_attic-ground, etc )
            local current_pos_actor = db.actor:position()
            -- X-side triangle Z-side triangle
            local IS_IT_SAFE_DISTANCE_XYZ =
                (math_sqrt(
                (current_pos_actor.x - tonumber(tp[1])) ^ 2 +
                    (current_pos_actor.z - tonumber(tp[3])) ^ 2
            ) > SAFE_DISTANCE_AROUND_PLAYER) or ((tonumber(tp[2]) - current_pos_actor.y) > 20)
            -- PERCENTAGE_TO_SPAWN
            local RNG_p = math_random(1, 100)
            -- PERCENTAGE_TO_SPAWN a CHIMERA_GIANT
            local RNG_pp = math_random(1, 100)
            -- spawn dyn_mutants at that position
            if
                (is_it_UG_map_ENG_NAME(map_pos)) and (ADDON_DISABLED_0_VALUE == false) and
                    (RNG_pp <= PERCENTAGE_TO_SPAWN_CHIMERA_GIANT_delayed) and
                    (IDs_utilized_current_number < 55000) and
                    (RNG_p <= (PERCENTAGE_TO_SPAWN_UG_MUTANTS + RNG_percentage)) and
                    IS_IT_SAFE_DISTANCE_XYZ
             then
                printf("spawning dynamic mutant %s", chosen_mutant)
                local se = sim:create(chosen_mutant, pos, lid, gid)
                -- to store the ID number in a field in the table
                MUTANT_IDS_IN_A_TABLE_UG[se.id] = se:name()
            -- dyn_mutants are spawned at that position
            end
        end
        ini = nil
        k = nil
        n = nil
        m = nil
        v = nil
        tp = nil
        RNG_p = nil
        chosen_mutant = nil
        -- at this point, UG maps are populated with the appropriate mutants
        --- now, UG maps need to be populated with a few appropraite stalkers
        if (not ADD_STALKERS) then
            -- if ADD_STALKERS is disabled
        else
            --[[ -- unaccessible to other stalkers, without first activating the elevator
-- Outskirts_Underground
if ( math_random(0,100) < 35 ) then
temp_table = append_alife_table (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )
elseif ( math_random(0,100) < 70 ) then
temp_table = append_alife_table (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )
else
temp_table = append_alife_table (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )
end
spawn_stalkers_in_UG_maps ( temp_table, "OUTSKIRTS_UG_POS" )
--]]
            --[[ -- unaccessible to other stalkers, without first activating the elevator
-- Monolith WarLab_Underground
if ( math_random(0,100) < 35 ) then
temp_table = append_alife_table (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )
elseif ( math_random(0,100) < 70 ) then
temp_table = append_alife_table (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )
else
temp_table = append_alife_table (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )
end
spawn_stalkers_in_UG_maps ( temp_table, "MONOLITH_WAR_LAB_UG_POS" )
--]]
            ------------------------------------------------------------------------
            -- the addition of stalkers is not disabled, thus, continue with adding a few od them
            local temp_table = {}
            ------------------------------------------------------------------------
            -- NOTE: you can add additional mutants here, spedific to a UG map
            -- it doesn't all have to be stalkers
            -- Agroprom_Underground
            -- the last value/column is for CONTROLLER+prob
            -- will spawn on UG - stalkers rec _positions
            if (math_random(0, 100) < 45) then
                -- a bit more stalkers
                if (math_random(0, 100) < 40) then
                    temp_table = append_alife_table(5, 2, 1, 11, 7, 0, 0, 35, 0, 0, 0, 0, 0, 3)
                else
                    temp_table = append_alife_table(10, 2, 1, 7, 3, 0, 0, 0, 0, 0, 0, 35, 0, 9)
                end
            else
                -- a bit more mutants
                if (math_random(0, 100) < 40) then
                    temp_table = append_alife_table(5, 3, 2, 11, 7, 0, 0, 22, 0, 0, 0, 0, 0, 7)
                else
                    temp_table = append_alife_table(10, 7, 1, 9, 3, 0, 0, 0, 0, 0, 0, 20, 0, 10)
                end
            end
            spawn_stalkers_in_UG_maps(temp_table, "AGROPROM_UG_POS")
            -- Yantar_Underground
            if (math_random(0, 100) < 35) then
                temp_table = append_alife_table(10, 0, 7, 8, 7, 0, 55, 0, 0, 0, 0, 0, 0, 2)
            else
                temp_table = append_alife_table(10, 0, 0, 12, 3, 0, 0, 0, 55, 0, 0, 0, 0, 1)
            end
            spawn_stalkers_in_UG_maps(temp_table, "YANTAR_UG_POS")
            -- Jupiter_Underground
            if (math_random(0, 100) < 35) then
                temp_table = append_alife_table(0, 0, 0, 3, 5, 2, 50, 0, 0, 0, 0, 0, 0, 3)
            elseif (math_random(0, 100) < 70) then
                temp_table = append_alife_table(0, 0, 0, 4, 4, 3, 0, 0, 50, 0, 0, 0, 0, 2)
            else
                temp_table = append_alife_table(0, 0, 0, 5, 4, 2, 0, 0, 0, 50, 0, 0, 0, 4)
            end
            spawn_stalkers_in_UG_maps(temp_table, "JUPITER_UG_POS")
            -- Dark Valley _Underground
            if (math_random(0, 100) < 45) then
                temp_table = append_alife_table(10, 10, 0, 5, 3, 0, 0, 0, 0, 0, 0, 30, 0, 8)
            else
                temp_table = append_alife_table(0, 0, 0, 5, 3, 0, 0, 0, 0, 0, 0, 60, 0, 4)
            end
            spawn_stalkers_in_UG_maps(temp_table, "DARK_VALLEY_UG_POS")
            -- Radar_Underground
            if (math_random(0, 100) < 40) then
                temp_table = append_alife_table(2, 2, 0, 7, 5, 0, 0, 0, 0, 0, 0, 0, 45, 3)
            elseif (math_random(0, 100) < 75) then
                temp_table = append_alife_table(4, 3, 0, 5, 4, 0, 0, 0, 0, 0, 0, 0, 35, 3)
            else
                temp_table = append_alife_table(8, 4, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 15, 2)
            end
            spawn_stalkers_in_UG_maps(temp_table, "RADAR_UG_POS")
        end -- end of the check if ENABLE_STALKERS is enabled/disabled
    end -- =====================================================================================
    -- to run several 'waves' at once, (instead of only one)
    MUTANT_IDS_IN_A_TABLE_UG = clean_out_table_from_nonmatching_ids_vs_field_contents(MUTANT_IDS_IN_A_TABLE_UG)
    msg(" ------- UG MAPS POPULATED ")
    msg(" ------- UG MAPS - Alife added: " .. __count_correct_ids_in_table__(MUTANT_IDS_IN_A_TABLE_UG))
end
--------- ===================================================================================== ---------
-- this function will add appropriate stalkers in all UG maps, and add their IDs along with the UG mutants

function spawn_stalkers_in_UG_maps(alife_table, section_to_read_pos_from)
    local current_slider_setting = dyn_mutants_target_numbers
    if (current_slider_setting > 1200) then
        current_slider_setting = 1200
    end -- to give a 'ceiling' for the factor, ( otherwise, at 2000+ slider setting, it would have twice the numbers in UG and SPEC_LOC )
    -- 1000 -- 0.1
    local PERCENTAGE_TO_SPAWN_UG_MUTANTS =
        dyn_mutants_target_numbers * PERCENTAGE_TO_SPAWN_UG_MUTANTS_factor
    msg(" -- current_slider_setting UG: " .. current_slider_setting)
    -- add an additional variety in the percentage numbers 70-120 %
    PERCENTAGE_TO_SPAWN_UG_MUTANTS = PERCENTAGE_TO_SPAWN_UG_MUTANTS * math_random(55, 120) / 100
    local ini = ini_file("plugins\\____gather_position_data_MUTANTS_MISC.ltx") -- the file holding the STALKERS and SPECIFIC_LOCATIONS rec_pos
    local n = ini:line_count(section_to_read_pos_from)
    local sim = alife()
    for k = 0, n - 1 do
        local result, i, v = ini:r_line_ex(section_to_read_pos_from, k)
        local tp = v and str_explode(v, ",")
        local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
        local lid = tonumber(tp[4])
        local gid = tonumber(tp[5])
        local m = math_random(1, #alife_table)
        local chosen_alife = alife_table[m]
        -- UPDATE: if "zombie_normal" is chosen, select a random one from the full zombie_table
        -- otherwise, it usually adds 1-3 in the roster, and only uses them
        local ALIFE_ZOMBIES = {
            "poltergeist_build",
            "zombie_normal",
            "zombie_strong",
            "zombie_weak",
            "zombie_ghol",
            "zombi_x3",
            "zombi_x4",
            "zombi_x3",
            "zombi_x4",
            "zombi_9",
            "zombie_wich",
            "zombi_babka_1",
            "zombi_babka_2",
            "zombi_babka_3",
            "zombie_teta",
            "zombie_fake"
        } -- "zombie_blind",
        if (chosen_alife == "zombie_normal") then
            chosen_alife = ALIFE_ZOMBIES[math_random(1, #ALIFE_ZOMBIES)]
        end
        local RNG_perc = math_random(STALKERS_PERC_VARIETY_MIN, STALKERS_PERC_VARIETY_MAX) -- to increase variety even more, and make the Stalkers appear some times in low numbers
        -- example: 40 -30 , 40 +10 i.e. 10 - 50 %
        if (PERCENTAGE_TO_SPAWN_UG_MUTANTS == 0) then
            RNG_perc = 0
        end -- in case the lider is set at '0'
        if
            (ADDON_DISABLED_0_VALUE == false) and (math_random(0, 100) <= (PERCENTAGE_TO_SPAWN_UG_MUTANTS + RNG_perc)) and
                (IDs_utilized_current_number < 55000)
         then
            -- if 'chosen_alife' is one of the ALIFE_MISC, (controller,burer...), check whether they are enabled
            if
                (chosen_alife == "m_controller_normal") or (chosen_alife == "m_controller_normal1111") or
                    (chosen_alife == "burer_normal")
             then
                if ENABLE_MISC_ALIFE then
                    msg("SPAWNED CONTROLLER/BURER in UG maps")
                    printf("spawning dynamic mutant %s", chosen_alife)
                    local se = sim:create(chosen_alife, pos, lid, gid)
                    MUTANT_IDS_IN_A_TABLE_UG[se.id] = se:name()
                end
            elseif ADD_STALKERS then
                printf("spawning dynamic mutant %s", chosen_alife)
                local se = sim:create(chosen_alife, pos, lid, gid)
                MUTANT_IDS_IN_A_TABLE_UG[se.id] = se:name()
            end
        end
    end
    --- ================================ additional fleeing rats UG maps =======================================
    local counter_rats_fleeing_UG = 0 -- NOTE: stalkers UG rec_pos range from 7 to 21, (Radar_UG)
    -- so, 10-65% should be good
    local MIN_perc = 35 -- 10
    local MAX_perc = 75 -- 25
    local RNG_perc = math_random(MIN_perc, MAX_perc)
    -- a rather important detail: seeing rats flee from danger, in the opposite direction from where you are going...
    -- manages to successfully convey the ambience in an UG location
    -- go through the Stalkers rec_pos again. 20% percentage + RNG should do it
    for k = 0, n - 1 do
        local result, i, v = ini:r_line_ex(section_to_read_pos_from, k)
        local tp = v and str_explode(v, ",")
        local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
        local lid = tonumber(tp[4])
        local gid = tonumber(tp[5])
        if (ADDON_DISABLED_0_VALUE == false) and (math_random(0, 100) <= RNG_perc) then
            local se = sim:create("rat_normal", pos, lid, gid)
            MUTANT_IDS_IN_A_TABLE_UG[se.id] = se:name()
            counter_rats_fleeing_UG = counter_rats_fleeing_UG + 1
        -- msg (" --- UG fleeing rat spawned: " .. se:name() )
        end
    end
    msg(
        " --- UG fleeing rat spawned, " ..
            section_to_read_pos_from ..
                ": %c[yellow]" ..
                    counter_rats_fleeing_UG ..
                        " " .. tonumber(string.format("%.1f", counter_rats_fleeing_UG / n * 100)) .. "%c[default] %"
    ) -- it will show numbers for the five UG maps included, (aside from Outskirts_UG, MonolithWarLab)
    --- ================================ additional fleeing rats =======================================
end

-- METHOD1: 'extracting' the weather from the weather presets: "w_foggy1", etc...
-- type of weather: {"clear","partly","cloudy","foggy","rain","storm"}

local get_weather_manager = level_weathers.get_weather_manager
local function get_current_weather()
  return get_weather_manager():get_curr_weather() or ""
end

function check_current_weather()
    local WeatherNews = get_current_weather()
    -- UPDATE: it may rain, but still say "cloudy", so, make a rain.factor check, and a >200m fog.distance checks, to 'override' if necessary
    local RainFactor = level.rain_factor() -- 0.2+ rain 0.7+ storm, 0.2- cloudy
    local FarDistance = weather.get_value_numric("fog_distance") -- < 200m foggy (actually, <100)
    if (RainFactor < 0.2) and (FarDistance < 100) then
        WeatherNews = "foggy"
    end
    if (RainFactor >= 0.2) then
        if (RainFactor >= 0.7) then
            WeatherNews = "storm"
        else
            WeatherNews = "rain"
        end
    end
    return WeatherNews
end
------------------------------------------------------------------
--[[
-- METHOD2: Data 'extracted' from weather presets:
clear partly cloudy rain storm fog
rain.factor 0 0 0 0.41-0.87 0.677-0.92 0
fog.distance 650 450 325-500 365-540 365-500 150-340
-->
0 650 clear
0 450 partly
0 325 and "rainy" cloudy
0.3-0.65 ---- rain
> 0.65 ---- storm
0 < 200 foggy
--]]
--type of weather: {"clear","partly","cloudy","foggy","rain","storm"}

function check_current_weather_ALT()
    local _WM = level_weathers.get_weather_manager()
    local WeatherType = _WM:get_curr_weather()
    if not (WeatherType) then
        return false
    end
    msg(" ------------------------------------------------------------------------ ")
    msg(
        "------ " ..
            WeatherType ..
                " rain_factor: " .. level.rain_factor() .. " fog_distance: " .. weather.get_value_numric("fog_distance")
    )
    local RainFactor = level.rain_factor() -- 0.5+ rain 0.9+ storm, 0.4- cloudy
    local FarDistance = weather.get_value_numric("fog_distance")
    local WeatherNews = "clear1111"
    if (RainFactor < 0.2) then
        if (FarDistance > 600) then
            WeatherNews = "clear"
        elseif (FarDistance > 500) then
            WeatherNews = "partly"
        elseif (FarDistance >= 200) and ((WeatherType == "rain") or (WeatherType == "storm")) then
            WeatherNews = "===cloudy"
        elseif (FarDistance < 200) then
            WeatherNews = "foggy"
        end
    end
    if (RainFactor >= 0.2) then
        if (RainFactor >= 0.7) then
            WeatherNews = "storm"
        else
            WeatherNews = "rain"
        end
    end
    return WeatherNews
end
----------------------- ======================================================== -------------------------

------- 'custom' precentage per SPEC_LOCATION, for incr./decr. numbers, in addition to the 'gloval' SPEC_LOC perc ------
local spec_loc_custom_perc = {
    ["zaton_iron_forest"] = 0.87,
    ["zaton_bs_lair"] = 1.05,
    ["zaton_controller_cave"] = 1.15,
    ["jupiter_volkhov_complex"] = 0.95,
    ["jupiter_abandoned_factory"] = 0.95,
    ["dead_city_abandoned_school"] = 1.05,
    ["army_warehouses_bs_village"] = 0.95,
    ["truck_cemetery_forest"] = 0.78,
    ["meadows_building_factory"] = 1.05,
    ["radar_ne_base"] = 0.95
}
-- "clear", "partly", "cloudy", "foggy", "rain", "storm"
-- if the current weather is foggy,stormy,rainy, increase the percentage by an additional 20-35 %
local spec_loc_weathers = {
    ["foggy"] = true,
    ["rain"] = true,
    ["storm"] = true,
    ["cloudy"] = true
}

-- here is the section that defines certain 'scenarios', (Alife contents encountered), at the spec_loc,
-- may be dependent on some condition, (time of day, RNG, night, rainy, fog, politics, story progress...)
-- "clear","partly","cloudy","foggy","rain","storm"
-- to potentially implement as a check for certain scenarios


-- if (section_to_read_pos_from == "zaton_iron_forest") then
--     local LONERS
--     local MERCS
--     if (math_random(0, 100) < 45) then
--         LONERS = math_random(22, 34)
--         MERCS = 0
--     else
--         LONERS = 0
--         MERCS = math_random(22, 34)
--     end
--     if (math_random(0, 100) < 60) then
--         temp_table = append_alife_table(18, 9, 3, 11, 12, 7, LONERS, 0, MERCS, 0, 0, 0, 0, 5)
--     else
--         temp_table = append_alife_table(20, 10, 5, 15, 8, 5, LONERS, 0, MERCS, 0, 0, 0, 0, 7)
--     end
--     populate_with_custom_alife_spec_loc(temp_table, PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS, section_to_read_pos_from)
-- end

local dyn_mutants_spec_loc_functions = {
    ["zaton_iron_forest"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        local LONERS
        local MERCS
        if (math_random(0, 100) < 45) then
            LONERS = math_random(22, 34)
            MERCS = 0
        else
            LONERS = 0
            MERCS = math_random(22, 34)
        end
        if (math_random(0, 100) < 60) then
            temp_table = append_alife_table(18, 9, 3, 11, 12, 7, LONERS, 0, MERCS, 0, 0, 0, 0, 5)
        else
            temp_table = append_alife_table(20, 10, 5, 15, 8, 5, LONERS, 0, MERCS, 0, 0, 0, 0, 7)
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["zaton_bs_lair"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        if (math_random(0, 100) < 60) then
            temp_table = append_alife_table(20, 10, 5, 80, 5, 0, 20, 0, 0, 0, 0, 0, 0, 0)
        else
            temp_table = append_alife_table(20, 10, 5, 80, 5, 0, 0, 0, 25, 0, 0, 0, 0, 0)
        end
        -- if HOUR is 21 - 4 then more BS present, less humans
        if (level.get_time_hours() >= 21) or (level.get_time_hours() <= 4) then
            temp_table = append_alife_table(5, 3, 2, 85, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0)
        else
            temp_table = append_alife_table(5, 3, 2, 85, 2, 0, 0, 0, 15, 0, 0, 0, 0, 0)
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["zaton_controller_cave"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        -- for the first 5 days, the Controlller is probably still there
        --- after that, BS/Lurkers may (want to) settle in
        if (get_time_elapsed_from_new_game_start() > 5) then
            temp_table = append_alife_table(20, 0, 0, 5, 30, 0, 0, 0, 0, 0, 0, 0, 0, 8)
        else
            temp_table = append_alife_table(20, 0, 0, 40, 10, 0, 0, 0, 0, 0, 0, 0, 0, 12)
        end
        -- probability for a Controller and/or Burer to inhabit the cave
        if (get_time_elapsed_from_new_game_start() > 3) and (math_random(0, 100) < 45) then
            temp_table = append_alife_table(10, 0, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0, 0, 15)
        end
        -- after 10th day, probability for a Chimera(+Lurkers) to inhabit the cave, (or other large predator)
        if (get_time_elapsed_from_new_game_start() > 10) and (math_random(0, 100) < 65) then
            -- solitary, big animal
            if (math_random(0, 100) < 55) then
                temp_table = append_alife_table(55, 0, 0, 0, 3, 35, 0, 0, 0, 0, 0, 0, 0, 2)
            else
                temp_table = append_alife_table(65, 0, 0, 0, 2, 45, 0, 0, 0, 0, 0, 0, 0, 2)
            end
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["jupiter_volkhov_complex"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        local r = math_random(0, 100)
        if (r < 35) then
            temp_table = append_alife_table(25, 17, 7, 20, 30, 10, 30, 0, 0, 0, 0, 0, 0, 12)
        elseif (r < 75) then
            temp_table = append_alife_table(15, 15, 8, 50, 40, 11, 0, 0, 0, 60, 0, 0, 0, 7)
        else
            temp_table = append_alife_table(30, 18, 8, 30, 15, 14, 0, 0, 40, 0, 0, 0, 0, 8)
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["jupiter_abandoned_factory"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        -- at night, a bit less stalkers, more mutants, compared to day
        if (level.get_time_hours() >= 21) or (level.get_time_hours() <= 4) then
            if (math_random(0, 100) < 45) then
                temp_table = append_alife_table(35, 25, 10, 45, 10, 11, 0, 0, 35, 0, 0, 0, 0, 11)
            else
                temp_table = append_alife_table(30, 15, 5, 30, 35, 12, 0, 0, 0, 42, 0, 0, 0, 12)
            end
        else -- at day
            if (math_random(0, 100) < 45) then
                temp_table = append_alife_table(35, 25, 10, 45, 10, 9, 0, 0, 45, 0, 0, 0, 0, 12)
            else
                temp_table = append_alife_table(30, 10, 5, 30, 35, 11, 0, 0, 0, 55, 0, 0, 0, 12)
            end
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["dead_city_abandoned_school"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        if (math_random(0, 100) < 45) then
            temp_table = append_alife_table(30, 18, 7, 35, 20, 0, 0, 25, 0, 0, 0, 0, 0, 8)
        else
            temp_table = append_alife_table(30, 15, 5, 20, 15, 0, 0, 0, 30, 0, 0, 0, 0, 22)
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["army_warehouses_bs_village"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        local FREEDOMERS
        local DUTYERS
        if (math_random(0, 100) < 45) then
            FREEDOMERS = math_random(12, 28)
            DUTYERS = 0
        else
            FREEDOMERS = 0
            DUTYERS = math_random(12, 28)
        end
        -- if HOUR is 21 - 4 then more BS present
        if (level.get_time_hours() >= 21) or (level.get_time_hours() <= 4) then
            if (math_random(0, 100) < 60) then
                temp_table = append_alife_table(11, 3, 3, 75, 12, 2, 0, 0, 0, FREEDOMERS, DUTYERS, 0, 0, 15)
            else
                temp_table = append_alife_table(10, 2, 2, 75, 9, 1, 0, 0, 0, FREEDOMERS, DUTYERS, 0, 0, 14)
            end
        else
            if (math_random(0, 100) < 60) then
                temp_table = append_alife_table(10, 1, 1, 45, 9, 2, 0, 0, 0, FREEDOMERS, DUTYERS, 0, 0, 9)
            else
                temp_table = append_alife_table(12, 1, 1, 45, 8, 2, 0, 0, 0, FREEDOMERS, DUTYERS, 0, 0, 7)
            end
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["truck_cemetery_forest"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        local DUTYERS
        local ARMY
        local MONOLITH
        local r = math_random(0, 100)
        local legit_weathers = {
            ["foggy"] = true,
            ["rain"] = true,
            ["storm"] = true
        }
        if (r < 40) then
            DUTYERS = math_random(10, 35)
            ARMY = 0
            MONOLITH = 0
        elseif (r < 73) then
            DUTYERS = 0
            ARMY = math_random(10, 35)
            MONOLITH = 0
        else
            DUTYERS = 0
            ARMY = 0
            MONOLITH = math_random(10, 35)
        end
        -- at night, less humans, more monsters
        -- during day, a bit more 'even' numbers
        --- if it is day and foggy/rainy, relatively more mutants
        if (level.get_time_hours() >= 21) or (level.get_time_hours() <= 4) then
            if (math_random(0, 100) < 45) then
                temp_table = append_alife_table(4, 3, 2, 65, 10, 14, 0, 0, 0, 0, DUTYERS, ARMY - 10, MONOLITH - 10, 0)
            else
                temp_table = append_alife_table(5, 5, 2, 50, 25, 17, 0, 0, 0, 0, DUTYERS, ARMY - 10, MONOLITH - 10, 0)
            end
        else
            if legit_weathers[current_weather] then
                if (math_random(0, 100) < 45) then
                    temp_table = append_alife_table(4, 3, 2, 55, 10, 17, 0, 0, 0, 0, DUTYERS, ARMY, MONOLITH, 0)
                else
                    temp_table = append_alife_table(5, 5, 2, 40, 25, 13, 0, 0, 0, 0, DUTYERS, ARMY, MONOLITH, 0)
                end
            else
                if (math_random(0, 100) < 45) then
                    temp_table = append_alife_table(4, 3, 2, 45, 10, 11, 0, 0, 0, 0, DUTYERS, ARMY, MONOLITH, 0)
                else
                    temp_table = append_alife_table(7, 5, 2, 35, 15, 11, 0, 0, 0, 0, DUTYERS, ARMY, MONOLITH, 0)
                end
            end
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["meadows_building_factory"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        if (math_random(0, 100) < 60) then
            temp_table = append_alife_table(50, 30, 10, 25, 30, 15, 35, 0, 0, 0, 0, 0, 0, 5)
        else
            temp_table = append_alife_table(40, 30, 12, 35, 15, 12, 0, 35, 0, 0, 0, 0, 0, 7)
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end,

    ["radar_ne_base"] = function(perc, sec, current_weather, ini)
        local temp_table = {}
        local MONOLITH = math_random(12, 35)
        if (math_random(0, 100) < 60) then
            temp_table = append_alife_table(20, 10, 15, 35, 20, 7, 0, 0, 0, 0, 0, 0, MONOLITH, 7)
        else
            temp_table = append_alife_table(20, 10, 5, 35, 12, 5, 0, 0, 0, 0, 0, 0, MONOLITH, 5)
        end
        populate_with_custom_alife_spec_loc(temp_table, perc, sec, ini)
    end
}

-- this function is executed after a 'trigger' has been activated, (after the checks)
local function spawn_dynamic_mutants_in_SPEC_LOC(section_to_read_pos_from, ini)
    -- append_alife_table (RODENTS_prob, ZOMBIES_prob, FRACTURES_prob, BLOODSUCKERS_prob, LURKERS_prob, CHIMERA_prob, LONERS_prob, BANDITS_prob, MERCS_prob, FREEDOM_prob, DUTY_prob, ARMY_prob, MONOLITH_prob )
    SPEC_LOC_got_populated_at_day = get_time_elapsed_from_new_game_start() -- set the day of visit, (depopulate after 2 days)
    local current_slider_setting = dyn_mutants_target_numbers
    if (current_slider_setting > 1200) then
        current_slider_setting = 1200
    end -- to give a 'ceiling' for the factor, ( otherwise, at 2000+ slider setting, it would have twice the numbers in UG and SPEC_LOC )
    -- typically = 0.05
    local PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS =
        dyn_mutants_target_numbers * PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS_factor
    msg(" -- current_slider_setting SPEC_LOC: " .. current_slider_setting)
    -- if it is during the night, increase the percentage by 30-55 %
    if (level.get_time_hours() >= 21) or (level.get_time_hours() <= 4) then
        PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS = PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS * math_random(120, 145) * 0.01
    end
    local current_weather = check_current_weather()
    -- NOTE: " = level_weathers.get_weather_manager():get_curr_weather()" gives somewhat inaccurate "assessment" of the current weather,
    -- so, I created a function that gives accurate weather assessment
    if spec_loc_weathers[current_weather] then
        PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS = PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS * math_random(110, 130) * 0.01
    end
    -- add an additional variety in the percentage numbers 70-110 %
    PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS = PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS * math_random(65, 110) * 0.01 * (spec_loc_custom_perc[section_to_read_pos_from] or 1)

    if dyn_mutants_spec_loc_functions[section_to_read_pos_from] then
        dyn_mutants_spec_loc_functions[section_to_read_pos_from](PERCENTAGE_TO_SPAWN_SPEC_LOC_MUTANTS, section_to_read_pos_from, current_weather, ini)
    end
end
--------- ===================================================================================== ---------
-- this function takes: alife_appended_table, percentage, section with recorded pos, starting_line_with_rec_pos,
-- and randomly selects from the appended table, and spawns on recorded_pos, with the percentage given, and saves the ids in the table_with_ids
-- NOTE: call upon and read/write in the IDs_table separately

function populate_with_custom_alife_spec_loc(alife_table, percentage, section_to_read_pos_from, ini)
    -- to get the current ID utilization, and check VS a limit (ex: 55.000), on whether to add more mutants, etc...
    -- NOTE: it makes a ~100ms stutter; not very noticeable when a new 'wave' of 1000s+ of mutants are spawned/added thr. the Zone
    IDs_utilized_current_number = 0 -- UPDATE: it is not really necessary to count this, this function adds at most 40-50 IDs
    local ini = ini or ini_file("plugins\\____gather_position_data_MUTANTS_MISC.ltx") -- the file holding the STALKERS and SPECIFIC_LOCATIONS rec_pos
    local n = ini:line_count(section_to_read_pos_from)
    local counter_spec_loc = 0
    local counter_spec_loc_1 = 0

    -- Probability to spawn a fleeing rat
    -- NOTE: with 30% or higher, rats can get 'stuck' grouped in a corner, (ex: at the first stairs in Zaton,Iron Forest)
    local MIN_perc = 15 -- 10 -- with up to 25, this doesn't seem to happen there, rats flee un-impeded
    local MAX_perc = 25 -- 35
    local sim = alife()

    -- UPDATE: if "zombie_normal" is chosen, select a random one from the full zombie_table
    -- otherwise, it usually adds 1-3 in the roster, and only uses them
    -- UPDATE2: adds (noticeably) to the stutter for the SPEC_LOC spawns, , better to 'disable' this
    -- for the UG maps, the extra 100-200ms is not really important
    -- here, it makes a difference
    local ALIFE_ZOMBIES = {
        "zombie_normal",
        "zombie_strong",
        "zombie_weak",
        "zombie_ghol",
        "zombi_x3",
        "zombi_x4",
        "zombi_x3",
        "zombi_x4",
        "zombi_9",
        "zombie_wich",
        "zombi_babka_1",
        "zombi_babka_2",
        "zombi_babka_3",
        "zombie_teta",
        "zombie_fake"
    } -- "zombie_blind",
    for k = 0, n - 1 do
        local result, i, v = ini:r_line_ex(section_to_read_pos_from, k)
        local tp = v and str_explode(v, ",")
        local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
        local lid = tonumber(tp[4])
        local gid = tonumber(tp[5])
        local chosen_alife = alife_table[math_random(#alife_table)]
        if (chosen_alife == "zombie_normal") then
            chosen_alife = ALIFE_ZOMBIES[math_random(#ALIFE_ZOMBIES)]
        end
        -- ================================ adding a fleeing rat at this position =======================================
        if not ADDON_DISABLED_0_VALUE and math_random(0, 100) < math_random(MIN_perc, MAX_perc) then
            local se = sim:create("rat_normal", pos, lid, gid)
            MUTANT_IDS_IN_A_TABLE_SPEC_LOC[se.id] = se:name()
            counter_spec_loc_1 = counter_spec_loc_1 + 1
        end
        -- ==============================================================================================================
        -- if (chosen_alife == "poltergeist_build") then
        --     msg(" ----- POLTERGEIST_CORP spawned in SPEC_LOC")
        -- end
        if not ADDON_DISABLED_0_VALUE and math_random(0, 100) <= percentage then
            -- if a STALKER is chosen, check whether their addition is enabled
            if string_match(chosen_alife, "sim_") then
                if ADD_STALKERS then
                    printf("spawning dynamic mutant %s", chosen_alife)
                    local se = sim:create(chosen_alife, pos, lid, gid)
                    MUTANT_IDS_IN_A_TABLE_SPEC_LOC[se.id] = se:name()
                    counter_spec_loc = counter_spec_loc + 1
                end
            else ------------- if a mutant is chosen
                -- first, check for the DAYS_DELAY for the CHIMERA, spawn only past the delay
                if string_match(chosen_alife, "chimera") then
                    if get_time_elapsed_from_new_game_start() >= DELAY_SPAWN_OF_CHIMERA_GIANT_FOR_THE_FIRST_N_DAYS then
                        -- a probability to 'switch' the chosen Chimera with one of the additional mutants, (if they are enabled/selected in the SETTINGS)
                        -- check first whether they all are enabled/disabled
                        if  dyn_mutants_enable_all_additional_mutants and
                            math_random(0, 100) < addit_mutants_at_SPEC_LOC_instead_of_a_chosen_chimera_prob
                        then
                            chosen_alife = add_an_additional_mutant_predator_instead_of_the_chosen_chimera(section_to_read_pos_from)
                            msg("SPAWNED at SPEC_LOC: " .. chosen_alife)
                        end
                        printf("spawning dynamic mutant %s", chosen_alife)
                        local se = sim:create(chosen_alife, pos, lid, gid)
                        MUTANT_IDS_IN_A_TABLE_SPEC_LOC[se.id] = se:name()
                        counter_spec_loc = counter_spec_loc + 1
                    end
                else -- for all other mutants, (non-BS, non-Chimera)
                    -- if it is one of the ALIFE_MISC, (controller,burer...), check whether they are enabled
                    if  chosen_alife == "m_controller_normal" or
                        chosen_alife == "m_controller_normal1111" or
                        chosen_alife == "burer_normal"
                    then
                        if ENABLE_MISC_ALIFE then
                            msg("SPAWNED CONTROLLER/BURER in SPEC_LOC")
                            printf("spawning dynamic mutant %s", chosen_alife)
                            local se = sim:create(chosen_alife, pos, lid, gid)
                            MUTANT_IDS_IN_A_TABLE_SPEC_LOC[se.id] = se:name()
                            counter_spec_loc = counter_spec_loc + 1
                        end
                    else -- for non-ALIFE_MISC mutants
                        printf("spawning dynamic mutant %s", chosen_alife)
                        local se = sim:create(chosen_alife, pos, lid, gid)
                        MUTANT_IDS_IN_A_TABLE_SPEC_LOC[se.id] = se:name()
                        counter_spec_loc = counter_spec_loc + 1
                    end
                end
            end
        end
    end
    --[[ -- UPDATE: it is implemented for every rec_pos, optimization reasons, slighly lesser stutter
--- ================================ additional fleeing rats SPEC_LOC =======================================
local counter_spec_loc_1 = 0
-- NOTE: with 30% or higher, rats can get 'stuck' grouped in a corner, (ex: at the first stairs in Zaton,Iron Forest)
local MIN_perc = 15 -- 10 -- with up to 25, this doesn't seem to happen there, rats flee un-impeded
local MAX_perc = 25 -- 35
local RNG_perc = math_random ( MIN_perc, MAX_perc )
-- a rather important detail: seeing rats flee from danger, in the opposite direction from where you are going...
-- manages to successfully convey that location as dangerous
-- so, go through the rec_pos again. 20% percentage + RNG should do it
for k=0, n-1 do
local result,i,v = ini:r_line_ex( section_to_read_pos_from ,k)
local tp = v and str_explode(v,",")
local pos = vector():set(tonumber(tp[1]),tonumber(tp[2]),tonumber(tp[3]))
local lid = tonumber(tp[4])
local gid = tonumber(tp[5])
if ( ADDON_DISABLED_0_VALUE == false ) and ( math_random(0,100) < RNG_perc ) then
local se = alife():create( "rat_normal" ,pos,lid,gid)
MUTANT_IDS_IN_A_TABLE_SPEC_LOC [se.id] = se:name()
counter_spec_loc_1 = counter_spec_loc_1 + 1
end
end
--- ================================ additional fleeing rats =======================================
--]]
    -- msg(
    --     " --- SPEC_LOC_SPAWN triggered. ADDED: %c[yellow]" ..
    --         counter_spec_loc ..
    --             "%c[default] and fleeing rats: %c[yellow]" ..
    --                 tonumber(string.format("%.1f", counter_spec_loc_1 / n * 100)) .. "%c[default] %"
    -- )
end
--------- ===================================================================================== ---------
--------- ===================================================================================== ---------
-- NOTE: this process of appending the table, adds up to 100-200ms in the stutter
-- decreasing this might be impactful
-- UPDATE: even giving a pre-set table of ten entries, doesn't noticeably decrease the stutter
-- --> most of the stutter seems to come from the spawning process, so, optimizing the append_table process won't do much,
-- this function takes mutant probabilities, stalkers probabilities , 'appends' a table and returns it back

local ALIFE_RODENTS = {
    "rat_normal",
    "rat_strong",
    "tushkano_normal",
    "tushkano_strong_b",
    "rat_normal",
    "rat_strong",
    "tushkano_normal",
    "tushkano_strong_b",
    "rat_normal",
    "rat_strong"
}
-- UPDATE: usually, it chooses 1-3 zombies for the Alife roster, and it uses only them in a particluar SPEC_LOC instance
-- so, when a "zombie_normal" is the entry in roster, spawn a random zombie from the full zombie_table
local ALIFE_ZOMBIES = {
    "zombie_normal",
    "zombie_normal",
    "zombie_normal",
    "zombie_normal",
    "zombie_normal",
    "zombie_normal",
    "zombie_normal",
    "zombie_normal",
    "zombie_normal",
    "zombie_normal"
}
-- local ALIFE_ZOMBIES = {"zombie_normal", "zombie_strong", "zombie_weak", "zombie_ghol", "zombi_x3", "zombi_x4", "zombi_9", "zombie_wich", "zombi_babka_1", "zombi_babka_2", }
local ALIFE_FRACTURES = {
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "fracture_weak",
    "fracture_normal",
    "fracture_weak"
}
local ALIFE_BLOODSUCKERS = {
    "bloodsucker_weak",
    "bloodsucker_normal",
    "bloodsucker_strong",
    "bloodsucker_normal",
    "bloodsucker_weak",
    "bloodsucker_normal",
    "bloodsucker_strong",
    "bloodsucker_normal",
    "bloodsucker_weak",
    "bloodsucker_normal"
}
local ALIFE_LURKERS = {
    "lurker_1_weak",
    "lurker_2_normal",
    "lurker_3_strong",
    "lurker_2_weak",
    "lurker_1_weak",
    "lurker_2_normal",
    "lurker_3_strong",
    "lurker_2_weak",
    "lurker_1_weak",
    "lurker_2_normal"
}
local ALIFE_CHIMERA = {
    "chimera_strong",
    "chimera_weak",
    "chimera_normal",
    "chimera_strong4",
    "chimera_strong",
    "chimera_weak",
    "chimera_normal",
    "chimera_strong4",
    "chimera_strong4",
    "chimera_weak"
}
-- to include different types of missions/'scenarios'. ex: rookie-experienced stalkers venturing (for loot) in UG locations, OR veterans/heavies going on a mission
-- Monolithians need to be mostly non-rookie, (they'll be seen in Radar and UG, guarding)
-- light-medium 'class' stalkers, (medium-heavy Monolithias, overall)
local ALIFE_LONERS = {
    "sim_default_stalker_0",
    "sim_default_stalker_1",
    "sim_default_stalker_2",
    "sim_default_stalker_0",
    "sim_default_stalker_1",
    "sim_default_stalker_2",
    "sim_default_stalker_0",
    "sim_default_stalker_1",
    "sim_default_stalker_2",
    "sim_default_stalker_0"
}
local ALIFE_BANDITS = {
    "sim_default_bandit_0",
    "sim_default_bandit_1",
    "sim_default_bandit_2",
    "sim_default_bandit_0",
    "sim_default_bandit_1",
    "sim_default_bandit_2",
    "sim_default_bandit_0",
    "sim_default_bandit_1",
    "sim_default_bandit_2",
    "sim_default_bandit_0"
}
local ALIFE_MERCS = {
    "sim_default_killer_0",
    "sim_default_killer_1",
    "sim_default_killer_2",
    "sim_default_killer_0",
    "sim_default_killer_1",
    "sim_default_killer_2",
    "sim_default_killer_0",
    "sim_default_killer_1",
    "sim_default_killer_2",
    "sim_default_killer_0"
}
local ALIFE_FREEDOM = {
    "sim_default_freedom_0",
    "sim_default_freedom_1",
    "sim_default_freedom_2",
    "sim_default_freedom_0",
    "sim_default_freedom_1",
    "sim_default_freedom_2",
    "sim_default_freedom_0",
    "sim_default_freedom_1",
    "sim_default_freedom_2",
    "sim_default_freedom_0"
}
local ALIFE_DUTY = {
    "sim_default_duty_0",
    "sim_default_duty_1",
    "sim_default_duty_2",
    "sim_default_duty_0",
    "sim_default_duty_1",
    "sim_default_duty_2",
    "sim_default_duty_0",
    "sim_default_duty_1",
    "sim_default_duty_2",
    "sim_default_duty_0"
}
local ALIFE_ARMY = {
    "sim_default_military_0",
    "sim_default_military_1",
    "sim_default_military_0",
    "sim_default_military_1",
    "sim_default_military_2",
    "sim_default_military_0",
    "sim_default_military_1",
    "sim_default_military_2",
    "sim_default_military_0"
}
local ALIFE_MONOLITH = {
    "sim_default_monolith_1",
    "sim_default_monolith_2",
    "sim_default_monolith_3",
    "sim_default_monolith_1",
    "sim_default_monolith_2",
    "sim_default_monolith_3",
    "sim_default_monolith_1",
    "sim_default_monolith_2",
    "sim_default_monolith_3",
    "sim_default_monolith_1"
}

-- in UG maps, on stalkers' rec_pos
local ALIFE_MISC = {
    "m_controller_normal",
    "m_controller_normal1111",
    "burer_normal",
    "burer_normal",
    "m_controller_normal",
    "poltergeist_build",
    "poltergeist_build"
}

function append_alife_table(
    RODENTS_prob,
    ZOMBIES_prob,
    FRACTURES_prob,
    BLOODSUCKERS_prob,
    LURKERS_prob,
    CHIMERA_prob,
    LONERS_prob,
    BANDITS_prob,
    MERCS_prob,
    FREEDOM_prob,
    DUTY_prob,
    ARMY_prob,
    MONOLITH_prob,
    ALIFE_MISC_prob)
    -- initialize the suitable alife tables
    -- note: the probability for any mutant/stalker, (utilized in the function), it actually determines whether or not each entry of theirs will be included in the resultant, 'appended' roster_table
    -- UPDATE: 10 entries each, (instead of 4), to make the roster more 'refined',
    -- i.e. the probabilities will have a more detailed 'impact' as a result
    -- example: LONERS_prob of 45%
    -- with 4 entries --> 1 or 2 LONER names added to the roster
    -- with 10 entries --> 4 or 5 LONER names added to the roster
    -- 10 entries for each table, for a similar chance to be present
    -- i.e. the '_prob' supplied determined the prob that each entry gets included in the 'roster'
    -- so, with same number of entries for all, and thr same prob --> similar chances for all
    -- UPDATE: adding a bit more Rats VS Tushkanos improves immersion
    -- rats seldom attack, they mostly flee. the latter 'helps' the ambience of an abandoned structure/location
    -- tushkanos can be even slightly annoying, even more so, when in high numbers. when in small numbers, they can distract the Player, when they need to deal with other threats
    -- either way, seeing Rats/Tushkanos almost everywhere is critical for immersion.
    ---- one would expect them to be ubiquitous in a place like the Zone

    -- medium-heavy 'class' stalkers (35-45% prob, at 3rd day and after OR 55-75% prob, at 10th day and after)
    local current_day = get_time_elapsed_from_new_game_start()
    if
        (math_random(0, 100) < math_random(35, 45) and current_day >= 3) or
        (math_random(0, 100) < math_random(55, 65) and current_day >= 10)
    then
        msg(" -- SPEC_LOC heavy stalkers chosen")
        local ALIFE_LONERS = {
            "sim_default_stalker_2",
            "sim_default_stalker_3",
            "sim_default_stalker_2",
            "sim_default_stalker_3",
            "sim_default_stalker_2",
            "sim_default_stalker_3",
            "sim_default_stalker_2",
            "sim_default_stalker_3",
            "sim_default_stalker_2",
            "sim_default_stalker_3"
        }
        local ALIFE_BANDITS = {
            "sim_default_bandit_2",
            "sim_default_bandit_3",
            "sim_default_bandit_2",
            "sim_default_bandit_3",
            "sim_default_bandit_2",
            "sim_default_bandit_3",
            "sim_default_bandit_2",
            "sim_default_bandit_3",
            "sim_default_bandit_2",
            "sim_default_bandit_3"
        }
        local ALIFE_MERCS = {
            "sim_default_killer_2",
            "sim_default_killer_3",
            "sim_default_killer_2",
            "sim_default_killer_3",
            "sim_default_killer_2",
            "sim_default_killer_3",
            "sim_default_killer_2",
            "sim_default_killer_3",
            "sim_default_killer_2",
            "sim_default_killer_3"
        }
        local ALIFE_FREEDOM = {
            "sim_default_freedom_2",
            "sim_default_freedom_3",
            "sim_default_freedom_2",
            "sim_default_freedom_3",
            "sim_default_freedom_2",
            "sim_default_freedom_3",
            "sim_default_freedom_2",
            "sim_default_freedom_3",
            "sim_default_freedom_2",
            "sim_default_freedom_3"
        }
        local ALIFE_DUTY = {
            "sim_default_duty_2",
            "sim_default_duty_3",
            "sim_default_duty_2",
            "sim_default_duty_3",
            "sim_default_duty_2",
            "sim_default_duty_3",
            "sim_default_duty_2",
            "sim_default_duty_3",
            "sim_default_duty_2",
            "sim_default_duty_3"
        }
        local ALIFE_ARMY = {
            "sim_default_military_2",
            "sim_default_military_3",
            "sim_default_military_2",
            "sim_default_military_3",
            "sim_default_military_2",
            "sim_default_military_3",
            "sim_default_military_2",
            "sim_default_military_3",
            "sim_default_military_2",
            "sim_default_military_3"
        }
    end
    --]]

    -- 5 entries, i.e. 'half', for half the probability for a COntroller/Burer to show up, as opposed to a Stalker
    local temp_table = {} -- to gather the necessary alife_names here
    local temp_table_counter = 1
    -- ------ go through all the 13 tables and append entries dependent of probability given
    -- UPDATE: for this twice, resulting in a twice longer table, for a more 'refined' roster/selection when choosing an Alife from it
    -- =====================================================================================

    -- for iii = 1, ALIFE_RODENTS_COUNT do
    --     if (math_random(1, 100) <= RODENTS_prob) then
    --         temp_table[temp_table_counter] = ALIFE_RODENTS[iii]
    --         temp_table_counter = temp_table_counter + 1
    --     end
    -- end

    local function alife_probability_func(prob, t)
        for i = 1, #t do
            if (math_random(1, 100) <= prob) then
                temp_table[temp_table_counter] = t[i]
                temp_table_counter = temp_table_counter + 1
            end
        end
    end

    local alife_filtered_functions = {}
    local alife_filtered_functions_counter = 1
    if RODENTS_prob and RODENTS_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(RODENTS_prob, ALIFE_RODENTS)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if ZOMBIES_prob and ZOMBIES_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(ZOMBIES_prob, ALIFE_ZOMBIES)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if FRACTURES_prob and FRACTURES_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(FRACTURES_prob, ALIFE_FRACTURES)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if BLOODSUCKERS_prob and BLOODSUCKERS_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(BLOODSUCKERS_prob, ALIFE_BLOODSUCKERS)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if LURKERS_prob and LURKERS_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(LURKERS_prob, ALIFE_LURKERS)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if CHIMERA_prob and CHIMERA_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(CHIMERA_prob, ALIFE_CHIMERA)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if LONERS_prob and LONERS_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(LONERS_prob, ALIFE_LONERS)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if BANDITS_prob and BANDITS_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(BANDITS_prob, ALIFE_BANDITS)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if MERCS_prob and MERCS_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(MERCS_prob, ALIFE_MERCS)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if FREEDOM_prob and FREEDOM_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(FREEDOM_prob, ALIFE_FREEDOM)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if DUTY_prob and DUTY_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(DUTY_prob, ALIFE_DUTY)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if ARMY_prob and ARMY_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(ARMY_prob, ALIFE_ARMY)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if MONOLITH_prob and MONOLITH_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(MONOLITH_prob, ALIFE_MONOLITH)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end
    if ALIFE_MISC_prob and ALIFE_MISC_prob > 0 then
        alife_filtered_functions[alife_filtered_functions_counter] = function()
            alife_probability_func(ALIFE_MISC_prob, ALIFE_MISC)
        end
        alife_filtered_functions_counter = alife_filtered_functions_counter + 1
    end

    for k = 1, 2 do
        for i = 1, #alife_filtered_functions do
            alife_filtered_functions[i]()
        end
    end
    -- =====================================================================================
    -- ----- the appended table now consists of all the entries, in accordance to the probabilities given
    return temp_table
end

local large_wide_areas = {
    ["zaton_controller_cave"] = true,
    ["jupiter_volkhov_complex"] = true,
    ["jupiter_abandoned_factory"] = true,
    ["truck_cemetery_forest"] = true,
    ["meadows_building_factory"] = true
}

function is_large_wide_SPEC_LOC_area(current_SPEC_LOC)
    -- Specific_Locations:
    -- "zaton_iron_forest", "zaton_bs_lair", "zaton_controller_cave", "jupiter_volkhov_complex", "jupiter_abandoned_factory"
    -- "dead_city_abandoned_school", "army_warehouses_bs_village", "truck_cemetery_forest", "meadows_building_factory", "radar_ne_base"
    -- with large, wide areas, suitable for bigger addit.mutants, (vendigo, medved, volk_top_dog, monster bear):
    -- "zaton_controller_cave", "jupiter_volkhov_complex", "jupiter_abandoned_factory", "truck_cemetery_forest", "meadows_building_factory",
    return large_wide_areas[current_SPEC_LOC]
end

local VOLK_NAMES_SMALL_for_SPEC_LOC = {"mwolf_leader"}
local VOLK_NAMES_LARGE_for_SPEC_LOC = {"mwolf_maverick", "mwolf_top_dog"}
local MEDVED_NAMES_for_SPEC_LOC = {"medved", "medved_dark"}
local TARK_NAMES_for_SPEC_LOC = {"tark_smaller", "tark_default"}
local MONSTER_BOAR_NAMES_for_SPEC_LOC = {"boar_big_monster", "boar_big_monster_v2"}
local VENDIGO_NAMES_for_SPEC_LOC = {"vendigo"}
local VANILLA_GIANT_NAMES_for_SPEC_LOC = {"gigant_strong", "gigant_jumper", "gigant_jumper"} -- "gigant_normal",
-- --> with two entries each, similar prob for all
-- NOTE: more entries here ^^ -> higher probability to be chosen and show up more frequently
-- NOTE: all these can only show up after the first 10 days have passed, so, the Player is a bit better equipped to be able to deal with them
-- NOTE: these mutants can show up in the Controller's cave in Zaton, among other. Vendigo, Monster Boar, Giant, Chimera, Medved - are all very suitable for there, as their (temporary) lair.

function add_an_additional_mutant_predator_instead_of_the_chosen_chimera(current_SPEC_LOC)
    local temp_table = {} -- we'll be gathering the necessary mutant_names here

    -- relatively smaller mutants, suitable for tight, UG corridors/areas:
    if dyn_mutants_enable_volk then
        temp_table = append_tables(temp_table, VOLK_NAMES_SMALL_for_SPEC_LOC)
    end
    if dyn_mutants_enable_tark then
        temp_table = append_tables(temp_table, TARK_NAMES_for_SPEC_LOC)
    end
    -- add these also, ONLY IF the SPEC_LOC is a large/wise area (or the Controller's cave in Zaton)
    -- big mutants, suitable for large/wise SPEC_LOC ONLY:
    if large_wide_areas[current_SPEC_LOC] then
        if dyn_mutants_enable_volk then
            temp_table = append_tables(temp_table, VOLK_NAMES_LARGE_for_SPEC_LOC)
        end
        if dyn_mutants_enable_medved then
            temp_table = append_tables(temp_table, MEDVED_NAMES_for_SPEC_LOC)
        end
        if dyn_mutants_enable_monster_boar then
            temp_table = append_tables(temp_table, MONSTER_BOAR_NAMES_for_SPEC_LOC)
        end
        if dyn_mutants_enable_vendigo then
            temp_table = append_tables(temp_table, VENDIGO_NAMES_for_SPEC_LOC)
        end
        -- add the GIANT name_entries here also
        temp_table = append_tables(temp_table, VANILLA_GIANT_NAMES_for_SPEC_LOC)
    end
    -- in the instance that this field is empty
    if #temp_table == 0 then
        return "chimera_normal"
    end
    return temp_table[math_random(#temp_table)]
end
------------ functions added for populating the UG maps and the SPECIFIC_LOCATIONS ------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------

function is_mutant__ambiental_fauna(mutant_victim)
    if (not mutant_victim) then
        return false
    end
    local found_a_match = false
    for i = 1, #ambiental_fauna_names do
        if (found_a_match == false) and (string_match(mutant_victim:name(), ambiental_fauna_names[i])) then
            found_a_match = true
        end
    end
    return found_a_match
end

-- ambiental_fauna__killed = 0 -- count them, global var, keep it in the save
-- function mutant_dead__check_friendly_fire(mutant_victim, killer_character)
--     -- actor id
--     if (killer_character:id() == AC_ID) then -- if the Actor/Player made the kill
--         if (is_mutant__ambiental_fauna(mutant_victim)) then -- Player killed amb_fauna animal, apply penalty
--             -------------------------------------------------- determine, apply penalty, and send a message
--             if (ambiental_fauna__killed < 0) then
--                 ambiental_fauna__killed = 0
--             end
--             ambiental_fauna__killed = ambiental_fauna__killed + 1
--             -- it starts with '0 days', one 'accidental' per day is acceptable
--             local deviation = ambiental_fauna__killed - get_time_elapsed_from_new_game_start()
--             local penalty_perc = 0
--             if (deviation > 0) then
--                 if (deviation <= 5) then
--                     penalty_perc = deviation / 100 -- i.e. 1% per 'penalty' kill
--                 else
--                     penalty_perc = (deviation - 4) * 5 / 100 -- i.e. 1% per 'penalty' kill
--                 end
--             end
--             if (penalty_perc > 1) then
--                 penalty_perc = 1
--             end
--             local roubles_amount_penalty = db.actor:money() * penalty_perc
--             db.actor:give_money(-roubles_amount_penalty)
--             if (roubles_amount_penalty > 0) then
--                 news_manager.send_tip(
--                     db.actor,
--                     "%c[yellow]'Friendly fauna' kill. %c[default]You lost %c[yellow]" ..
--                         string.format("%.0f", penalty_perc * 100) ..
--                             "%c[default] % of your money. %c[yellow]" ..
--                                 string.format("%.0f", roubles_amount_penalty) .. "%c[default] roubles.",
--                     nil,
--                     nil,
--                     12000
--                 )
--             else
--                 news_manager.send_tip(db.actor, "%c[yellow]'Friendly fauna' kill.", nil, nil, 12000)
--             end
--         -------------------------------------------------- ^^^ determine, apply penalty, and send a message
--         end
--     end
-- end
----------------------------------------------------------------------------------
--[[
--------------------------------------------------------------------------------------
-- NOTE/REMINDER: code added in bind_monster.script, before line 239 ( safe_release_manager.release(se_obj) )
-- to 'insert' a dead corporeal Poltegeist body when a Poltergeist dies off
-- added for DynMutants, add dead corporeal body when Poltergeist dies
if (string_match (se_obj:name(),"m_poltergeist_normal_tele")) or (string_match (se_obj:name(),"m_poltergeist_normal_flame")) then
local se = alife():create( "poltergeist_build" , se_obj.position, se_obj.m_level_vertex_id, se_obj.m_game_vertex_id )
local RNG_angle = math_random ( -100, 100 )
if ( math_random (1, 100) < 60 ) then
RNG_facing = 1
else
RNG_facing = -1
end
se.angle = vector():set(1.57 *RNG_facing, 0.03 *RNG_angle ,0) -- lying down, RNG angle on Y-axis, facing up or down
se:kill()
end
-- added for DynMutants, add dead corporeal body when Poltergeist dies
--------------------------------------------------------------------------------------
--]]
------ to save/load statistics_data in the gamesave ------------------

function save_state(m_data)
    -- local drink = {}
    -- drink.last_drink = last_drink
    -- drink.chk_drink = last_drink_chk and utils_data.CTime_to_table(last_drink_chk)
    -- m_data.drink = drink
    local dynamic_mutants_data_bmb = {}
    dynamic_mutants_data_bmb.last_time_to_spawn_dynamic_mutants = last_time_to_spawn_dynamic_mutants
    dynamic_mutants_data_bmb.next_time_to_spawn_dynamic_mutants = next_time_to_spawn_dynamic_mutants
    dynamic_mutants_data_bmb.PERCENTAGE_TO_SPAWN_MUTANTS = PERCENTAGE_TO_SPAWN_MUTANTS
    dynamic_mutants_data_bmb.TIMES_SPAWNED = TIMES_SPAWNED
    dynamic_mutants_data_bmb.LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON = LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON
    dynamic_mutants_data_bmb.timestamp_when_playthrough_started = timestamp_when_playthrough_started
    dynamic_mutants_data_bmb.TOTAL_NUMBER_OF_MUTANTS_ADDED = TOTAL_NUMBER_OF_MUTANTS_ADDED
    dynamic_mutants_data_bmb.NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE
    dynamic_mutants_data_bmb.MUTANTS_DEAD_COUNT = MUTANTS_DEAD_COUNT
    dynamic_mutants_data_bmb.ENOUGH_MUTANTS_CULLED = ENOUGH_MUTANTS_CULLED
    dynamic_mutants_data_bmb.WAIT_FOR_MUTANTS_TO_BE_CULLED_N = WAIT_FOR_MUTANTS_TO_BE_CULLED_N
    dynamic_mutants_data_bmb.MUTANT_IDS_IN_A_TABLE = MUTANT_IDS_IN_A_TABLE
    dynamic_mutants_data_bmb.MUTANT_IDS_IN_A_TABLE_UG = MUTANT_IDS_IN_A_TABLE_UG
    dynamic_mutants_data_bmb.MUTANT_IDS_IN_A_TABLE_SPEC_LOC = MUTANT_IDS_IN_A_TABLE_SPEC_LOC
    dynamic_mutants_data_bmb.UG_maps_got_populated_at_day = UG_maps_got_populated_at_day
    dynamic_mutants_data_bmb.SPECIFIC_LOCATIONS_populated = SPECIFIC_LOCATIONS_populated
    dynamic_mutants_data_bmb.UG_maps_are_populated = UG_maps_are_populated
    dynamic_mutants_data_bmb.UG_maps_got_populated_at_day = UG_maps_got_populated_at_day
    dynamic_mutants_data_bmb.SPECIFIC_LOCATIONS_populated = SPECIFIC_LOCATIONS_populated
    dynamic_mutants_data_bmb.SPEC_LOC_got_populated_at_day = SPEC_LOC_got_populated_at_day
    -- dynamic_mutants_data_bmb.ambiental_fauna__killed = ambiental_fauna__killed
    m_data.dynamic_mutants_data_bmb = dynamic_mutants_data_bmb
end

function load_state(m_data)
    if (not m_data.dynamic_mutants_data_bmb) then
        return
    end
    local dynamic_mutants_data_bmb = m_data.dynamic_mutants_data_bmb
    -- IMPORTANT: when loading a savegame that doesn't contain the DYN_NOCT_MUT data, it would crash when the script needs that data
    -- solution: " local variable = value or 0 " --> sets it to '0' if no data available
    last_time_to_spawn_dynamic_mutants = dynamic_mutants_data_bmb.last_time_to_spawn_dynamic_mutants or 0 -- to make it zero, instead of nil, (which would happen if loading a save that doesn't contain all this STAT data)
    next_time_to_spawn_dynamic_mutants = dynamic_mutants_data_bmb.next_time_to_spawn_dynamic_mutants or 0
    PERCENTAGE_TO_SPAWN_MUTANTS = dynamic_mutants_data_bmb.PERCENTAGE_TO_SPAWN_MUTANTS or 0 -- save the current percentage to spawn dyn_mutants
    TIMES_SPAWNED = dynamic_mutants_data_bmb.TIMES_SPAWNED or 0 -- the number of dyn_mutants 'waves' so far
    LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON = dynamic_mutants_data_bmb.LIMIT_OF_MUTANTS_ADDED_BY_THIS_ADDON or 2000
    timestamp_when_playthrough_started = dynamic_mutants_data_bmb.timestamp_when_playthrough_started or 0
    TOTAL_NUMBER_OF_MUTANTS_ADDED = dynamic_mutants_data_bmb.TOTAL_NUMBER_OF_MUTANTS_ADDED or 0
    NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE = dynamic_mutants_data_bmb.NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE or 0
    MUTANTS_DEAD_COUNT = dynamic_mutants_data_bmb.MUTANTS_DEAD_COUNT or 0
    ENOUGH_MUTANTS_CULLED = dynamic_mutants_data_bmb.ENOUGH_MUTANTS_CULLED or true
    WAIT_FOR_MUTANTS_TO_BE_CULLED_N =
        dynamic_mutants_data_bmb.WAIT_FOR_MUTANTS_TO_BE_CULLED_N or NUMBER_OF_MUTANTS_ADDED_IN_LAST_WAVE
    MUTANT_IDS_IN_A_TABLE = dynamic_mutants_data_bmb.MUTANT_IDS_IN_A_TABLE or {}
    MUTANT_IDS_IN_A_TABLE_UG = dynamic_mutants_data_bmb.MUTANT_IDS_IN_A_TABLE_UG or {}
    MUTANT_IDS_IN_A_TABLE_SPEC_LOC = dynamic_mutants_data_bmb.MUTANT_IDS_IN_A_TABLE_SPEC_LOC or {}
    UG_maps_are_populated = dynamic_mutants_data_bmb.UG_maps_are_populated or false
    UG_maps_got_populated_at_day = dynamic_mutants_data_bmb.UG_maps_got_populated_at_day or -30
    SPECIFIC_LOCATIONS_populated = dynamic_mutants_data_bmb.SPECIFIC_LOCATIONS_populated or {}
    SPEC_LOC_got_populated_at_day = dynamic_mutants_data_bmb.SPEC_LOC_got_populated_at_day or -30
    -- ambiental_fauna__killed = dynamic_mutants_data_bmb.ambiental_fauna__killed or 0
end
------ end of to save/load statistics_data in the gamesave ------------------
-- this function is transferred from RC18, U4H8 doesn't have it

-- this is executed "actor_on_update", i.e. at every frame, so, optimize/minimize the processing needed

-- ["zaton"] = function(ini, current_pos_actor)
--     local n = ini:line_count("zaton_iron_forest_triggers")
--     for k = 0, n - 1 do
--         local result, i, v = ini:r_line_ex("zaton_iron_forest_triggers", k)
--         local tp = v and str_explode(v, ",")
--         local pos = vector():set(tonumber(tp[1]), tonumber(tp[2]), tonumber(tp[3]))
--         local lid = tonumber(tp[4])
--         local gid = tonumber(tp[5])
--         if (math_abs(current_pos_actor.x - tonumber(tp[1])) < radius_to_SPEC_LOC) then
--             if (math_abs(current_pos_actor.z - tonumber(tp[3])) < radius_to_SPEC_LOC) then
--                 -- X-side triangle Z-side triangle
--                 if
--                     (SPECIFIC_LOCATIONS_populated.zaton_iron_forest ~= "populated") and
--                         (math_sqrt(
--                             math_abs(current_pos_actor.x - tonumber(tp[1])) ^ 2 +
--                                 math_abs(current_pos_actor.z - tonumber(tp[3])) ^ 2
--                         ) < radius_to_SPEC_LOC)
--                  then
--                     spawn_dynamic_mutants_in_SPEC_LOC("zaton_iron_forest")
--                     SPECIFIC_LOCATIONS_populated.zaton_iron_forest = "populated"
--                 end
--             end
--         end
--     end

local function spawn_spec_loc(ini, current_pos_actor, sec_triggers, sec, radius_spec)
    local n = ini:line_count(sec_triggers)
    for k = 0, n - 1 do
        local result, i, v = ini:r_line_ex(sec_triggers, k)
        local tp = v and str_explode(v, ",")
        local current_pos_actor_x = math_abs(current_pos_actor.x - tonumber(tp[1]))
        local current_pos_actor_z = math_abs(current_pos_actor.z - tonumber(tp[3]))
        if  current_pos_actor_x < radius_spec and
            current_pos_actor_z < radius_spec and
            SPECIFIC_LOCATIONS_populated[sec] ~= "populated" and
            math_sqrt(current_pos_actor_x * current_pos_actor_x + current_pos_actor_z * current_pos_actor_z) < radius_spec
        then
            spawn_dynamic_mutants_in_SPEC_LOC(sec, ini)
            SPECIFIC_LOCATIONS_populated[sec] = "populated"
        end
    end
end

-- go through all the 'trigger' coordinates,
-- and, if Player's pos is within radius of one,
-- run function 'spawn_dynamic_mutants_in_SPEC_LOC' that will handle all other parameters, probabilities, etc
-- to minimize the processing, first check only BY X coord, if within, then also BY Z, if within, then calculate the radius (circle)
local spawn_spec_loc_functions = {
    ["zaton"] = function(ini, current_pos_actor)
        spawn_spec_loc(ini, current_pos_actor, "zaton_iron_forest_triggers", "zaton_iron_forest", radius_to_SPEC_LOC)
        spawn_spec_loc(ini, current_pos_actor, "zaton_bs_lair_triggers", "zaton_bs_lair", radius_to_SPEC_LOC)
        spawn_spec_loc(ini, current_pos_actor, "zaton_controller_cave_triggers", "zaton_controller_cave", radius_to_SPEC_LOC)
    end,

    ["jupiter"] = function(ini, current_pos_actor)
        spawn_spec_loc(ini, current_pos_actor, "jupiter_volkhov_complex_triggers", "jupiter_volkhov_complex", radius_to_SPEC_LOC * 2)
        spawn_spec_loc(ini, current_pos_actor, "jupiter_abandoned_factory_triggers", "jupiter_abandoned_factory", radius_to_SPEC_LOC)
    end,

    ["l09_deadcity"] = function(ini, current_pos_actor)
        spawn_spec_loc(ini, current_pos_actor, "dead_city_abandoned_school_triggers", "dead_city_abandoned_school", radius_to_SPEC_LOC)
    end,

    ["l07_military"] = function(ini, current_pos_actor)
        spawn_spec_loc(ini, current_pos_actor, "army_warehouses_bs_village_triggers", "army_warehouses_bs_village", radius_to_SPEC_LOC * 2.6)
    end,

    ["k02_trucks_cemetery"] = function(ini, current_pos_actor)
        spawn_spec_loc(ini, current_pos_actor, "truck_cemetery_forest_triggers", "truck_cemetery_forest", radius_to_SPEC_LOC * 2.1)
    end,

    ["y04_pole"] = function(ini, current_pos_actor)
        spawn_spec_loc(ini, current_pos_actor, "meadows_building_factory_triggers", "meadows_building_factory", radius_to_SPEC_LOC)
    end,

    ["l10_radar"] = function(ini, current_pos_actor)
        spawn_spec_loc(ini, current_pos_actor, "radar_ne_base_triggers", "radar_ne_base", radius_to_SPEC_LOC)
    end
    ---- now, all 'trigger' coordinates are checked
}

local function check_whether_to_spawn_in_a_SPEC_LOC()
    local t = time_global()
    if t < actor_on_update_time then return end
    actor_on_update_time = t + actor_on_update_timer

    local current_map = level.name()
    if not spec_loc_map[current_map] then
        return -- do a quick check on whether the current map is among those with specific locations
    -- exit this function if not, (no further checks/processing necessary)
    end

    -- get Player's position
    local current_pos_actor = db.actor:position()
    local ini = ini_file("plugins\\____gather_position_data_MUTANTS_MISC.ltx")

    if spawn_spec_loc_functions[current_map] then
        -- printf("dyn mutants triggered %s", current_map)
        spawn_spec_loc_functions[current_map](ini, current_pos_actor)
    end
end

local function update_values()
    if ui_mcm then
        actor_on_update_timer = ui_mcm.get("dynamic_mutants/dyn_mutants_update_period")
        dyn_mutants_enable_volk = ui_mcm.get("dynamic_mutants/dyn_mutants_enable_volk")
        dyn_mutants_enable_tark = ui_mcm.get("dynamic_mutants/dyn_mutants_enable_tark")
        dyn_mutants_enable_medved = ui_mcm.get("dynamic_mutants/dyn_mutants_enable_medved")
        dyn_mutants_enable_monster_boar = ui_mcm.get("dynamic_mutants/dyn_mutants_enable_monster_boar")
        dyn_mutants_enable_vendigo = ui_mcm.get("dynamic_mutants/dyn_mutants_enable_vendigo")
        dyn_mutants_enable_piranha = ui_mcm.get("dynamic_mutants/dyn_mutants_enable_piranha")
        dyn_mutants_enable_shepherd_fox_birds = ui_mcm.get("dynamic_mutants/dyn_mutants_enable_shepherd_fox_birds")
        dyn_mutants_enable_all_additional_mutants = ui_mcm.get("dynamic_mutants/dyn_mutants_enable_all_additional_mutants")
        dyn_mutants_target_numbers = ui_mcm.get("dynamic_mutants/dyn_mutants_target_numbers")
    end
end

function on_game_start()
    --RegisterScriptCallback("monster_on_death_callback", mutant_dead__check_friendly_fire)
    RegisterScriptCallback("on_option_change", remove_unselected_additional_mutants)
    RegisterScriptCallback("on_option_change", set_max_numbers_limit)
    RegisterScriptCallback("on_option_change", update_values)
    RegisterScriptCallback("actor_on_first_update", update_values)
    RegisterScriptCallback("actor_on_first_update", set_max_numbers_limit)
    RegisterScriptCallback("on_level_changing", check_whether_to_spawn_dynamic_mutants)
    RegisterScriptCallback("actor_on_sleep", check_whether_to_spawn_dynamic_mutants)
    RegisterScriptCallback("actor_on_first_update", spawn_dynamic_mutants_in_UG_maps) -- populate UG maps on visit
    RegisterScriptCallback("actor_on_first_update", check_whether_to_despawn_UG_MAPS_population) -- de-populate UG maps, if no visit for a few days AND Player is in a non_UG map
    RegisterScriptCallback("actor_on_sleep", check_whether_to_despawn_UG_MAPS_population)
    RegisterScriptCallback("actor_on_update", check_whether_to_spawn_in_a_SPEC_LOC) -- track Player's pos, in regards to the specific_locations
    RegisterScriptCallback("actor_on_first_update", check_whether_to_despawn_SPEC_LOC_population) -- de-populate SPECIFIC_LOCATIONS, if no visit for a few days AND Player is in another map
    RegisterScriptCallback("actor_on_sleep", check_whether_to_despawn_SPEC_LOC_population)
    RegisterScriptCallback("save_state", save_state) -- save/load required data
    RegisterScriptCallback("load_state", load_state)
end